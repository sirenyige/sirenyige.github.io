<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NoSQL</title>
    <url>/NoSQL/</url>
    <content><![CDATA[<h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p><strong>NoSQL 方案带来的优势，本质上是牺牲 ACID 中的某个或者某几个特性，因此我们不能盲目地迷信 NoSQL 是银弹，而应该将 NoSQL 作为 SQL 的一个有力补充，NoSQL != No SQL，而是 NoSQL = Not Only SQL。</strong></p>
<p>常见的 NoSQL 方案分为 4 类。</p>
<ul>
<li>K-V 存储：解决关系数据库无法存储数据结构的问题，以 Redis 为代表。</li>
<li>文档数据库：解决关系数据库强 schema 约束的问题，以 MongoDB 为代表。</li>
<li>列式数据库：解决关系数据库大数据场景下的 I/O 问题，以 HBase 为代表。</li>
<li>全文搜索引擎：解决关系数据库的全文搜索性能问题，以 Elasticsearch 为代表。</li>
</ul>
<a id="more"></a>
<p>关系数据库经过几十年的发展后已经非常成熟，强大的 SQL 功能和 ACID 的属性，使得关系数据库广泛应用于各式各样的系统中，但关系数据库仍存在如下缺点：</p>
<ul>
<li><p>关系数据库存储的是行记录，无法存储数据结构</p>
</li>
<li><p>关系数据库的 schema 扩展很不方便</p>
<p>关系数据库的表结构 schema 是强约束，操作不存在的列会报错，业务变化时扩充列也比较麻烦，需要执行 DDL（data definition language）语句修改，而且修改时可能会长时间锁表</p>
</li>
<li><p>关系数据库在大数据场景下 I/O 较高</p>
<p>即使只针对其中某一列进行运算，关系数据库也会将整行数据从存储设备读入内存。</p>
</li>
<li><p>关系数据库的全文搜索功能比较弱</p>
<p>关系数据库的全文搜索只能使用 like 进行整表扫描匹配，性能非常低</p>
</li>
</ul>
<h2 id="一、K-V-存储"><a href="#一、K-V-存储" class="headerlink" title="一、K-V 存储"></a>一、K-V 存储</h2><p>K-V 存储的全称是 Key-Value 存储，其中 Key 是数据的标识，和关系数据库中的主键含义一样，Value 就是具体的数据。</p>
<p>Redis 是 K-V 存储的典型代表，Redis 的缺点主要体现在并<strong>不支持完整的 ACID 事务</strong>，Redis 虽然提供事务功能，但 Redis 的事务和关系数据库的事务不可同日而语，Redis 的事务只能保证隔离性和一致性（I 和 C），无法保证原子性和持久性（A 和 D）。</p>
<h2 id="二、文档数据库"><a href="#二、文档数据库" class="headerlink" title="二、文档数据库"></a>二、文档数据库</h2><p>为了解决关系数据库 schema 带来的问题，文档数据库应运而生。文档数据库最大的特点就是 no-schema，可以存储和读取任意的数据。</p>
<p>优势：</p>
<ul>
<li><p>新增字段简单</p>
</li>
<li><p>历史数据不会出错</p>
<p>对于历史数据，即使没有新增的字段，也不会导致错误，只会返回空值，此时代码进行兼容处理即可。</p>
</li>
<li><p>可以很容易存储复杂数据</p>
</li>
</ul>
<p>文档数据库 no-schema 的特性带来的这些优势也是有代价的：</p>
<ul>
<li>最主要的代价就是不支持事务。</li>
<li>另外一个缺点就是无法实现关系数据库的 join 操作</li>
</ul>
<h2 id="三、列式数据库"><a href="#三、列式数据库" class="headerlink" title="三、列式数据库"></a>三、列式数据库</h2><p>列式数据库就是按照列来存储数据的数据库，与之对应的传统关系数据库被称为“行式数据库”，因为关系数据库是按照行来存储数据的。</p>
<h2 id="四、全文搜索引擎"><a href="#四、全文搜索引擎" class="headerlink" title="四、全文搜索引擎"></a>四、全文搜索引擎</h2><p>全文搜索引擎的技术原理被称为<strong>“倒排索引”</strong>（Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，其基本原理是建立单词到文档的索引。之所以被称为“倒排”索引，是和“正排“索引相对的，“正排索引”的基本原理是建立文档到单词的索引。</p>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
  </entry>
  <entry>
    <title>架构设计基本流程</title>
    <url>/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="架构设计基本流程"><a href="#架构设计基本流程" class="headerlink" title="架构设计基本流程"></a>架构设计基本流程</h1><a id="more"></a>
<h2 id="一、识别复杂度"><a href="#一、识别复杂度" class="headerlink" title="一、识别复杂度"></a>一、识别复杂度</h2><p>架构设计的本质目的是为了解决软件系统的复杂性，所以在我们设计架构时，首先就要分析系统的复杂性。</p>
<p><strong>将主要的复杂度问题列出来，然后根据业务、技术、团队等综合情况进行排序，优先解决当前面临的最主要的复杂度问题。</strong></p>
<h2 id="二、设计备选方案"><a href="#二、设计备选方案" class="headerlink" title="二、设计备选方案"></a>二、设计备选方案</h2><p>成熟的架构师需要对已经存在的技术非常熟悉，对已经经过验证的架构模式烂熟于心，然后根据自己对业务的理解，挑选合适的架构模式进行组合，再对组合后的方案进行修改和调整。</p>
<h3 id="2-1-错误一：设计最优秀的方案"><a href="#2-1-错误一：设计最优秀的方案" class="headerlink" title="2.1 错误一：设计最优秀的方案"></a>2.1 错误一：设计最优秀的方案</h3><p>根据架构设计原则中“合适原则”和“简单原则“的要求，挑选合适自己业务、团队、技术能力的方案才是好方案；否则要么浪费大量资源开发了无用的系统，要么根本无法实现。</p>
<h3 id="2-2-错误二：只做一个方案"><a href="#2-2-错误二：只做一个方案" class="headerlink" title="2.2 错误二：只做一个方案"></a>2.2 错误二：只做一个方案</h3><p>只做一个方案有很多弊端：</p>
<ol>
<li>心里评估过于简单，可能没有想得全面，只是因为某一个缺点就把某个方案给否决了，而实际上没有哪个方案是完美的，某个地方有缺点的方案可能是综合来看最好的方案。</li>
<li>经验知识和技能有局限，有可能某个评估的标准或者经验是不正确的，或者是老的经验不适合新的情况。</li>
<li>单一方案设计会出现过度辩护的情况，即架构评审时，针对方案存在的问题和疑问，架构师会竭尽全力去为自己的设计进行辩护，经验不足的设计人员可能会强词夺理。</li>
</ol>
<h3 id="2-3-错误三：备选方案过于详细"><a href="#2-3-错误三：备选方案过于详细" class="headerlink" title="2.3 错误三：备选方案过于详细"></a>2.3 错误三：备选方案过于详细</h3><p>有的架构师或者设计师在写备选方案时，错误地将备选方案等同于最终的方案，每个备选方案都写得很细。</p>
<ul>
<li>耗费了大量的时间和精力</li>
<li>将注意力集中到细节中，忽略了整体的技术设计，导致备选方案数量不够或者差异不大</li>
<li>评审的时候其他人会被很多细节给绕进去，评审效果很差</li>
</ul>
<h2 id="三、评估和选择备选方案"><a href="#三、评估和选择备选方案" class="headerlink" title="三、评估和选择备选方案"></a>三、评估和选择备选方案</h2><p>在完成备选方案设计后，如何挑选出最终的方案也是一个很大的挑战，主要原因有：</p>
<ul>
<li>每个方案都是可行的，如果方案不可行就根本不应该作为备选方案。</li>
<li>没有哪个方案是完美的。</li>
<li>评价标准主观性比较强。</li>
</ul>
<p><strong>列出我们需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案。</strong></p>
<p>误区：</p>
<ul>
<li><p>数量对比法：简单地看哪个方案的优点多就选哪个。</p>
<p>把所有质量属性的重要性等同，而没有考虑质量属性的优先级。</p>
</li>
<li><p>加权法：每个质量属性给一个权重，然后将每个方案的权重得分加起来，最后看哪个方案的权重得分最高就选哪个。</p>
<p>无法客观地给出每个质量属性的权重得分。</p>
</li>
</ul>
<p>正确的做法是<strong>按优先级选择</strong>，即综合当前的业务发展情况、团队人员规模和技能、业务发展预测等因素，将质量属性按照优先级排序，首先挑选满足第一优先级的，如果方案都满足，那就再看第二优先级……以此类推。</p>
<h2 id="四、详细方案设计"><a href="#四、详细方案设计" class="headerlink" title="四、详细方案设计"></a>四、详细方案设计</h2><p><strong>详细方案设计就是将方案涉及的关键技术细节给确定下来。</strong></p>
<p>详细设计方案阶段可能遇到的一种极端情况就是在详细设计阶段发现备选方案不可行，一般情况下主要的原因是备选方案设计时遗漏了某个关键技术点或者关键的质量属性。</p>
<p>避免措施：</p>
<ul>
<li>架构师不但要进行备选方案设计和选型，还需要对备选方案的关键细节有较深入的理解。</li>
<li>通过分步骤、分阶段、分系统等方式，尽量降低方案复杂度，方案本身的复杂度越高，某个细节推翻整个方案的可能性就越高，适当降低复杂性，可以减少这种风险。</li>
<li>如果方案本身就很复杂，那就采取设计团队的方式来进行设计，博采众长，汇集大家的智慧和经验，防止只有 1~2 个架构师可能出现的思维盲点或者经验盲区。</li>
</ul>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
  </entry>
  <entry>
    <title>高性能数据库结构</title>
    <url>/%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="高性能数据库结构"><a href="#高性能数据库结构" class="headerlink" title="高性能数据库结构"></a>高性能数据库结构</h1><p>关系数据库由于其 ACID 的特性和功能强大的 SQL 查询，目前还是各种业务系统中关键和核心的存储系统，很多场景下高性能的设计最核心的部分就是关系数据库的设计。</p>
<ul>
<li>高性能数据库集群的第一种方式是<strong>“读写分离”</strong>，其本质是将访问压力分散到集群中的多个节点，但是没有分散存储压力；</li>
<li>第二种方式是<strong>“分库分表”</strong>，既可以分散访问压力，又可以分散存储压力。</li>
</ul>
<a id="more"></a>
<h2 id="一、读写分离"><a href="#一、读写分离" class="headerlink" title="一、读写分离"></a>一、读写分离</h2><p><strong>读写分离的基本原理是将数据库读写操作分散到不同的节点上</strong></p>
<p>读写分离的基本实现是：</p>
<ul>
<li>数据库服务器搭建主从集群，一主一从、一主多从都可以。</li>
<li>数据库主机负责读写操作，从机只负责读操作。</li>
<li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。</li>
<li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机。</li>
</ul>
<p><strong>“从机”是需要提供读数据的功能的；而“备机”一般被认为仅仅提供备份功能，不提供访问功能。</strong></p>
<h3 id="1-1-主从复制延迟"><a href="#1-1-主从复制延迟" class="headerlink" title="1.1 主从复制延迟"></a>1.1 主从复制延迟</h3><p>主从复制延迟会带来一个问题：如果业务服务器将数据写入到数据库主服务器后立刻（1 秒内）进行读取，此时读操作访问的是从机，主机还没有将数据复制过来，到从机读取数据是读不到最新数据的，业务上就可能出现问题。</p>
<p>解决主从复制延迟有几种常见的方法：</p>
<ol>
<li>写操作后的读操作指定发给数据库主服务器</li>
<li>读从机失败后再读一次主机</li>
<li>关键业务读写操作全部指向主机，非关键业务采用读写分离</li>
</ol>
<h3 id="1-2-分配机制"><a href="#1-2-分配机制" class="headerlink" title="1.2 分配机制"></a>1.2 分配机制</h3><p>将读写操作区分开来，然后访问不同的数据库服务器，一般有两种方式：程序代码封装和中间件封装。</p>
<h4 id="1-2-1-程序代码封装"><a href="#1-2-1-程序代码封装" class="headerlink" title="1.2.1 程序代码封装"></a>1.2.1 程序代码封装</h4><ul>
<li>程序代码封装指在代码中抽象一个数据访问层，实现读写操作分离和数据库服务器连接的管理。</li>
<li>实现简单，而且可以根据业务做较多定制化的功能。每个编程语言都需要自己实现一次，无法通用，如果一个业务包含多个编程语言写的多个子系统，则重复开发的工作量比较大。</li>
</ul>
<h4 id="1-2-2-中间件封装"><a href="#1-2-2-中间件封装" class="headerlink" title="1.2.2 中间件封装"></a>1.2.2 中间件封装</h4><p>中间件封装指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供 SQL 兼容的协议，业务服务器无须自己进行读写分离。</p>
<ul>
<li>能够支持多种编程语言，因为数据库中间件对业务服务器提供的是标准 SQL 接口。</li>
<li>数据库中间件要支持完整的 SQL 语法和数据库服务器的协议（例如，MySQL 客户端和服务器的连接协议），实现比较复杂，细节特别多，很容易出现 bug，需要较长的时间才能稳定。</li>
<li>数据库中间件自己不执行真正的读写操作，但所有的数据库操作请求都要经过中间件，中间件的性能要求也很高。</li>
<li>数据库主从切换对业务服务器无感知，数据库中间件可以探测数据库服务器的主从状态。例如，向某个测试表写入一条数据，成功的就是主机，失败的就是从机。</li>
</ul>
<h2 id="二、分库分表"><a href="#二、分库分表" class="headerlink" title="二、分库分表"></a>二、分库分表</h2><h3 id="2-1-分库"><a href="#2-1-分库" class="headerlink" title="2.1 分库"></a>2.1 分库</h3><p>业务分库指的是按照业务模块将数据分散到不同的数据库服务器。虽然业务分库能够分散存储和访问压力，但同时也带来了新的问题：</p>
<ol>
<li><p>1.join 操作问题</p>
<p>业务分库后，原本在同一个数据库中的表分散到不同数据库中，导致无法使用 SQL 的 join 查询。</p>
</li>
<li><p>事务问题</p>
<p>原本在同一个数据库中不同的表可以在同一个事务中修改，业务分库后，表分散到不同的数据库中，无法通过事务统一修改。</p>
</li>
<li><p>成本问题</p>
<p>业务分库同时也带来了成本的代价，本来 1 台服务器搞定的事情，现在要 3 台，如果考虑备份，那就是 2 台变成了 6 台。</p>
</li>
</ol>
<h3 id="2-2-分表"><a href="#2-2-分表" class="headerlink" title="2.2 分表"></a>2.2 分表</h3><p>单表数据拆分有两种方式：垂直分表和水平分表。</p>
<ul>
<li>垂直切分，就是表记录数相同但包含不同的列。</li>
<li>水平切分，就是表的列相同但包含不同的行数据。</li>
</ul>
<h4 id="2-2-1-垂直分表"><a href="#2-2-1-垂直分表" class="headerlink" title="2.2.1 垂直分表"></a>2.2.1 垂直分表</h4><p>垂直分表适合将表中某些不常用且占了大量空间的列拆分出去。垂直分表引入的复杂性主要体现在表操作的数量要增加。</p>
<h4 id="2-2-2-水平分表"><a href="#2-2-2-水平分表" class="headerlink" title="2.2.2 水平分表"></a>2.2.2 水平分表</h4><p>水平分表适合表行数特别大的表，当看到表的数据量达到千万级别时，就要警觉起来，因为这很可能是架构的性能瓶颈或者隐患。</p>
<p>水平分表相比垂直分表，会引入更多的复杂性，主要表现在下面几个方面：</p>
<ul>
<li>路由</li>
<li>join 操作</li>
<li>count() 操作</li>
<li>order by 操作</li>
</ul>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
  </entry>
  <entry>
    <title>架构设计</title>
    <url>/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="架构设计的目的"><a href="#架构设计的目的" class="headerlink" title="架构设计的目的"></a>架构设计的目的</h1><p>架构设计的主要目的是为了<strong>解决软件系统复杂度带来的问题</strong>。</p>
<a id="more"></a>
<h2 id="一、高性能带来的复杂度"><a href="#一、高性能带来的复杂度" class="headerlink" title="一、高性能带来的复杂度"></a>一、高性能带来的复杂度</h2><h3 id="1-1-单机复杂度"><a href="#1-1-单机复杂度" class="headerlink" title="1.1 单机复杂度"></a>1.1 单机复杂度</h3><h3 id="1-2-集群的复杂度"><a href="#1-2-集群的复杂度" class="headerlink" title="1.2 集群的复杂度"></a>1.2 集群的复杂度</h3><h2 id="二、高可用带来的复杂度"><a href="#二、高可用带来的复杂度" class="headerlink" title="二、高可用带来的复杂度"></a>二、高可用带来的复杂度</h2><p>系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。</p>
<blockquote>
<p>高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。</p>
</blockquote>
<h3 id="2-1-CAP-定理"><a href="#2-1-CAP-定理" class="headerlink" title="2.1 CAP 定理"></a>2.1 CAP 定理</h3><p><strong>CAP定理</strong>（CAP theorem），又被称作<strong>布鲁尔定理</strong>（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<ul>
<li>一致性（<strong>C</strong>onsistency） （等同于所有节点访问同一份最新的数据副本）</li>
<li>可用性（<strong>A</strong>vailability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li>
<li>分区容错性（<strong>P</strong>artition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择）</li>
</ul>
<p>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项。</p>
<h3 id="2-2-计算高可用"><a href="#2-2-计算高可用" class="headerlink" title="2.2 计算高可用"></a>2.2 计算高可用</h3><h3 id="2-3-存储高可用"><a href="#2-3-存储高可用" class="headerlink" title="2.3 存储高可用"></a>2.3 存储高可用</h3><p>存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响。</p>
<h3 id="2-4-高可用状态决策"><a href="#2-4-高可用状态决策" class="headerlink" title="2.4 高可用状态决策"></a>2.4 高可用状态决策</h3><p>无论是计算高可用还是存储高可用，其<strong>基础都是“状态决策”</strong>，即系统需要能够判断当前的状态是正常还是异常，如果出现了异常就要采取行动来保证高可用。如果状态决策本身都是有错误或者有偏差的，那么后续的任何行动和处理无论多么完美也都没有意义和价值。</p>
<p><strong>通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确。</strong></p>
<h4 id="2-4-1-独裁式"><a href="#2-4-1-独裁式" class="headerlink" title="2.4.1 独裁式"></a>2.4.1 独裁式</h4><p>独裁式决策指的是存在一个独立的决策主体，我们姑且称它为“决策者”，负责收集信息然后进行决策；所有冗余的个体，我们姑且称它为“上报者”，都将状态信息发送给决策者。</p>
<p><strong>独裁式的决策方式不会出现决策混乱的问题，因为只有一个决策者，但当决策者本身故障时，整个系统就无法实现准确的状态决策。</strong></p>
<h4 id="2-4-2-协商式"><a href="#2-4-2-协商式" class="headerlink" title="2.4.2 协商式"></a>2.4.2 协商式</h4><p>协商式决策指的是两个独立的个体通过交流信息，然后根据规则进行决策，最常用的协商式决策就是主备决策。</p>
<p>协商式决策的架构不复杂，规则也不复杂，其难点在于，如果两者的信息交换出现问题（比如主备连接中断），此时状态决策应该怎么做。</p>
<h4 id="2-4-3-民主式"><a href="#2-4-3-民主式" class="headerlink" title="2.4.3 民主式"></a>2.4.3 民主式</h4><p>民主式决策指的是多个独立的个体通过投票的方式来进行状态决策。</p>
<p>民主式决策和协商式决策比较类似，其基础都是独立的个体之间交换信息，每个个体做出自己的决策，然后按照“多数取胜”的规则来确定最终的状态。</p>
<ul>
<li>民主式决策比协商式决策要复杂得多</li>
<li>除民主式决策还有一个固有的缺陷：脑裂。根本原因是，原来统一的集群因为连接中断，造成了两个独立分隔的子集群，每个子集群单独进行选举，于是选出了 2 个主机，相当于人体有两个大脑了。</li>
</ul>
<blockquote>
<p>为了解决脑裂问题，民主式决策的系统一般都采用“投票节点数必须超过系统总节点数一半”规则来处理。</p>
</blockquote>
<h2 id="三、可扩展性带来的复杂度"><a href="#三、可扩展性带来的复杂度" class="headerlink" title="三、可扩展性带来的复杂度"></a>三、可扩展性带来的复杂度</h2><p>可扩展性指系统为了应对将来需求变化而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。</p>
<p>设计具备良好可扩展性的系统，有两个基本条件：<strong>正确预测变化</strong>、<strong>完美封装变化</strong>。</p>
<h3 id="3-1-预测变化"><a href="#3-1-预测变化" class="headerlink" title="3.1 预测变化"></a>3.1 预测变化</h3><h3 id="3-2-应对变化"><a href="#3-2-应对变化" class="headerlink" title="3.2 应对变化"></a>3.2 应对变化</h3><ol>
<li>将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”。</li>
<li>提炼出一个“抽象层”和一个“实现层”。</li>
</ol>
<h2 id="四、低成本、安全、规模带来的复杂度"><a href="#四、低成本、安全、规模带来的复杂度" class="headerlink" title="四、低成本、安全、规模带来的复杂度"></a>四、低成本、安全、规模带来的复杂度</h2>]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
  </entry>
  <entry>
    <title>架构设计三原则</title>
    <url>/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%89%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="架构设计三原则"><a href="#架构设计三原则" class="headerlink" title="架构设计三原则"></a>架构设计三原则</h1><a id="more"></a>
<h2 id="一、合适原则"><a href="#一、合适原则" class="headerlink" title="一、合适原则"></a>一、合适原则</h2><p><strong>合适优于业界领先</strong></p>
<ol>
<li>没那么多人，却想干那么多活，是失败的第一个主要原因。</li>
<li>没有那么多积累，却想一步登天，是失败的第二个主要原因。</li>
<li>没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因。</li>
</ol>
<p>真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地。</p>
<h2 id="二、简单原则"><a href="#二、简单原则" class="headerlink" title="二、简单原则"></a>二、简单原则</h2><p><strong>简单优于复杂</strong></p>
<h3 id="2-1-结构的复杂性"><a href="#2-1-结构的复杂性" class="headerlink" title="2.1 结构的复杂性"></a>2.1 结构的复杂性</h3><p>结构复杂的系统特点：</p>
<ul>
<li>组成复杂系统的组件数量更多；</li>
<li>这些组件之间的关系也更加复杂。</li>
</ul>
<p>会带来以下问题：</p>
<ol>
<li>组件越多，就越有可能其中某个组件出现故障</li>
<li>某个组件改动，会影响关联的所有组件</li>
<li>定位一个复杂系统中的问题总是比简单系统更加困难</li>
</ol>
<h3 id="2-2-逻辑的复杂性"><a href="#2-2-逻辑的复杂性" class="headerlink" title="2.2 逻辑的复杂性"></a>2.2 逻辑的复杂性</h3><ul>
<li>一个典型特征就是<strong>单个组件承担了太多的功能</strong>。逻辑复杂几乎会导致软件工程的每个环节都有问题。</li>
<li>另外一个典型特征就是<strong>采用了复杂的算法</strong>。复杂算法导致的问题主要是难以理解，进而导致难以实现、难以修改，并且出了问题难以快速解决。</li>
</ul>
<h2 id="三、演化原则"><a href="#三、演化原则" class="headerlink" title="三、演化原则"></a>三、演化原则</h2><p><strong>演化优于一步到位</strong></p>
<p>软件架构需要根据业务发展不断变化：</p>
<ul>
<li>首先，设计出来的架构要满足当时的业务需要。</li>
<li>其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。</li>
<li>第三，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。</li>
</ul>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
  </entry>
  <entry>
    <title>架构基本概念</title>
    <url>/%E6%9E%B6%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="架构基本概念"><a href="#架构基本概念" class="headerlink" title="架构基本概念"></a>架构基本概念</h1><a id="more"></a>
<h2 id="一、系统与子系统"><a href="#一、系统与子系统" class="headerlink" title="一、系统与子系统"></a>一、系统与子系统</h2><p><strong>系统</strong>泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。它的意思是“总体”“整体”或“联盟”。</p>
<ol>
<li>关联：系统是由一群有关联的个体组成的，没有关联的个体堆在一起不能成为一个系统。</li>
<li>规则：系统内的个体需要按照指定的规则运作，而不是单个个体各自为政。规则规定了系统内个体分工和协作的方式。</li>
<li>能力：系统能力与个体能力有本质的差别，系统能力不是个体能力之和，而是产生了新的能力。</li>
</ol>
<p><strong>子系统</strong>也是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分。</p>
<blockquote>
<p>子系统的定义和系统定义是一样的，只是观察的角度有差异，一个系统可能是另外一个更大系统的子系统。</p>
</blockquote>
<h2 id="二、模块与组件"><a href="#二、模块与组件" class="headerlink" title="二、模块与组件"></a>二、模块与组件</h2><p><strong>软件模块（Module）</strong>是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。模块的接口表达了由该模块提供的功能和调用它时所需的元素。模块是可能分开被编写的单位。这使它们可再用和允许人员同时协作、编写及研究不同的模块。</p>
<p><strong>软件组件</strong>定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。</p>
<p><strong>模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已：</strong></p>
<ul>
<li><p>从逻辑的角度来拆分系统后，得到的单元就是“模块”，划分模块的主要目的是职责分离；</p>
</li>
<li><p>从物理的角度来拆分系统后，得到的单元就是“组件”，划分组件的主要目的是单元复用。</p>
</li>
</ul>
<h2 id="三、框架与架构"><a href="#三、框架与架构" class="headerlink" title="三、框架与架构"></a>三、框架与架构</h2><p><strong>软件框架</strong>（Software framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。</p>
<ol>
<li>框架是组件规范</li>
<li>框架提供基础功能的产品</li>
</ol>
<p><strong>软件架构</strong>指软件系统的“基础结构”，创造这些基础结构的准则，以及对这些结构的描述。</p>
<blockquote>
<p><strong>框架关注的是“规范”，架构关注的是“结构”。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
  </entry>
  <entry>
    <title>Java中的偏向锁、轻量级锁、重量级锁</title>
    <url>/Java%E4%B8%AD%E7%9A%84%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/</url>
    <content><![CDATA[<h1 id="Java中的偏向锁、轻量级锁、重量级锁"><a href="#Java中的偏向锁、轻量级锁、重量级锁" class="headerlink" title="Java中的偏向锁、轻量级锁、重量级锁"></a>Java中的偏向锁、轻量级锁、重量级锁</h1><a id="more"></a>
<h2 id="一、Java-对象头"><a href="#一、Java-对象头" class="headerlink" title="一、Java 对象头"></a>一、Java 对象头</h2><p>每一个 Java 对象都至少占用 2 个字宽的内存(数组类型占用3个字宽)。</p>
<ul>
<li>第一个字宽也被称为对象头<strong>Mark Word</strong>。 对象头包含了多种不同的信息， 其中就包含对象锁相关的信息。</li>
<li>第二个字宽是指向定义该对象类信息（class metadata）的指针</li>
</ul>
<p><img src="/Java中的偏向锁、轻量级锁、重量级锁/java对象头.png" alt="java对象头"></p>
<h2 id="二、无锁-gt-偏向锁"><a href="#二、无锁-gt-偏向锁" class="headerlink" title="二、无锁 -&gt; 偏向锁"></a>二、无锁 -&gt; 偏向锁</h2><ol>
<li><p>首先读取目标对象的 MarkWord, 判断是否处于可偏向的状态</p>
</li>
<li><p>如果为可偏向状态, 则尝试用 CAS 操作， 将自己的线程 ID 写入MarkWord</p>
<ul>
<li><p>如果 CAS 操作成功， 则认为已经获取到该对象的偏向锁， 执行同步块代码 。补充： 一个线程在执行完同步代码块以后， 并不会尝试将 MarkWord 中的 thread ID 赋回原值 。这样做的好处是： 如果该线程需要再次对这个对象加锁，而这个对象之前一直没有被其他线程尝试获取过锁，依旧停留在可偏向的状态下， 即可在不修改对象头的情况下， 直接认为偏向成功。</p>
</li>
<li><p>如果 CAS 操作失败， 则说明， 有另外一个线程 Thread B 抢先获取了偏向锁。 这种状态说明该对象的竞争比较激烈， 此时需要撤销 Thread B 获得的偏向锁，将 Thread B 持有的锁升级为轻量级锁。 该操作需要等待全局安全点 JVM safepoint ( 此时间点， 没有线程在执行字节码) 。</p>
</li>
</ul>
</li>
<li><p>如果是<strong>已偏向状态</strong>， 则检测 MarkWord 中存储的 thread ID 是否等于当前 thread ID 。</p>
<ul>
<li>如果相等， 则证明本线程已经获取到偏向锁， 可以直接继续执行同步代码块</li>
<li>如果不等， 则证明该对象目前偏向于其他线程， 需要<strong>撤销</strong>偏向锁</li>
</ul>
</li>
</ol>
<h2 id="三、偏向锁的撤销"><a href="#三、偏向锁的撤销" class="headerlink" title="三、偏向锁的撤销"></a>三、偏向锁的撤销</h2><p> 偏向锁的撤销（Revoke） 操作并不是将对象恢复到无锁可偏向的状态， 而是在偏向锁的获取过程中， 发现了竞争时， 直接将一个被偏向的对象“升级到” 被加了轻量级锁的状态。 </p>
<p>偏向锁的 <strong>撤销（revoke）</strong> 是一个很特殊的操作， 为了执行撤销操作， 需要等待<strong>全局安全点（Safe Point）</strong>， 此时间点所有的工作线程都停止了<strong>字节码</strong>的执行。</p>
<p>在偏向锁 CAS 更新操作失败以后， 等待到达全局安全点。<br>通过 MarkWord 中已经存在的 Thread Id 找到成功获取了偏向锁的那个线程, 然后在该线程的栈帧中补充上轻量级加锁时，会保存的锁记录（Lock Record），然后将被获取了偏向锁对象的 MarkWord 更新为指向这条锁记录的指针。<br>至此， 锁撤销操作完成， 阻塞在安全点的线程可以继续执行。</p>
<h2 id="四、偏向锁的批量再偏向"><a href="#四、偏向锁的批量再偏向" class="headerlink" title="四、偏向锁的批量再偏向"></a>四、偏向锁的批量再偏向</h2><p>偏向锁并没有直观意义上的“释放锁”操作， 提供了批量再偏向机制（Bulk Rebias）机制</p>
<ol>
<li>首先引入一个概念epoch，其本质是一个时间戳，代表了偏向锁的有效性，epoch存储在可偏向对象的MarkWord中。除了对象中的epoch,对象所属的类class信息中，也会保存一个epoch值。</li>
<li>每当遇到一个全局安全点时，比如要对class C 进行批量再偏向，则首先对 class C中保存的epoch进行增加操作，得到一个新的epoch_new</li>
<li>然后扫描所有持有 class C 实例的线程栈，根据线程栈的信息判断出该线程是否锁定了该对象，仅将epoch_new的值赋给被锁定的对象中，也就是现在偏向锁还在被使用的对象才会被赋值epoch_new。</li>
<li>退出安全点后，当有线程需要尝试获取偏向锁时，直接检查 class C 中存储的 epoch 值是否与目标对象中存储的 epoch 值相等， 如果不相等，则说明该对象的偏向锁已经无效了（因为（3）步骤里面已经说了只有偏向锁还在被使用的对象才会有epoch_new，这里不相等的原因是class C里面的epoch值是epoch_new,而当前对象的epoch里面的值还是epoch），此时竞争线程可以尝试对此对象重新进行偏向操作。</li>
</ol>
<h2 id="五、偏向锁-gt-轻量级锁"><a href="#五、偏向锁-gt-轻量级锁" class="headerlink" title="五、偏向锁 -&gt; 轻量级锁"></a>五、偏向锁 -&gt; 轻量级锁</h2><p>存在超过一个线程竞争某一个对象时， 会发生偏向锁的撤销操作。 偏向锁撤销后， 对象可能处于两种状态：</p>
<ul>
<li><p>一种是<strong>不可偏向的无锁状态</strong>（原来已经获取了偏向锁的线程已经执行完了同步代码块）</p>
</li>
<li><p>另一种是<strong>不可偏向的已锁 ( 轻量级锁) 状态</strong>（原来已经获取了偏向锁的线程也可能尚未执行完同步代码块）</p>
</li>
</ul>
<p>轻量级加锁</p>
<ol>
<li>在线程执行同步代码块之前，JVM会现在当前线程的栈桢中创建用于存储锁记录的空间，并将锁对象头中的 markWord 信息复制到锁记录中，这个官方称为 Displaced Mard Word。然后线程尝试使用 CAS 将对象头中的 MarkWord 替换为指向锁记录的指针。如果替换成功，则进入步骤2，失败则进入步骤3。</li>
<li>CAS 替换成功说明当前线程已获得该锁，此时在栈桢中锁标志位信息也更新为轻量级锁状态：00。此时的栈桢与锁对象头的状态如图二所示。</li>
<li>如果CAS 替换失败则说明当前时间锁对象已被某个线程占有，那么此时当前线程只有通过自旋的方式去获取锁。如果在自旋一定次数后仍为获得锁，那么轻量级锁将会升级成重量级锁。</li>
</ol>
<h2 id="六、重量级锁"><a href="#六、重量级锁" class="headerlink" title="六、重量级锁"></a>六、重量级锁</h2><p>重量级锁依赖于操作系统的互斥量（mutex） 实现，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Java字符串</title>
    <url>/Java%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="Java字符串"><a href="#Java字符串" class="headerlink" title="Java字符串"></a>Java字符串</h1><p><strong>String是典型的 Immutable 类</strong>，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。</p>
<p><strong>StringBuffer 是为解决字符串拼接产生太多中间对象的问题而提供的一个类</strong>，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，它的线程安全是通过把各种修改数据的方法都加上 synchronized 关键字实现的。</p>
<p><strong>StringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销</strong>，是绝大部分情况下进行字符串拼接的首选。</p>
<blockquote>
<p>StringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组</p>
</blockquote>
<a id="more"></a>
<p>非静态的拼接逻辑在 JDK 8 中会自动被 javac 转换为 StringBuilder 操作；而在 JDK 9 里面，则是体现了思路的变化。Java 9 利用 InvokeDynamic，将字符串拼接的优化与 javac 生成的字节码解耦，假设未来 JVM 增强相关运行时实现，将不需要依赖 javac 的任何修改。</p>
<p>Java 9 中引入了 Compact Strings 的设计，对字符串进行了大刀阔斧的改进。<strong>将数据存储方式从 char 数组，改变为一个 byte 数组加上一个标识编码的所谓 coder</strong>，并且将相关字符串操作类都进行了修改。另外，所有相关的 Intrinsic 之类也都进行了重写，以保证没有任何性能损失。</p>
<h2 id="典型面试题"><a href="#典型面试题" class="headerlink" title="典型面试题"></a>典型面试题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    s.intern();</span><br><span class="line">    String s2 = <span class="string">"1"</span>;</span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    s3.intern();</span><br><span class="line">    String s4 = <span class="string">"11"</span>;</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果是</p>
<ul>
<li>jdk6 下<code>false false</code></li>
<li>jdk7 下<code>false true</code></li>
</ul>
<blockquote>
<p><strong><code>String#intern</code> 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。</strong></p>
</blockquote>
<h3 id="1、jdk6"><a href="#1、jdk6" class="headerlink" title="1、jdk6"></a>1、jdk6</h3><p>在 jdk6中上述的所有打印都是 false 的，因为 jdk6中的常量池是放在 Perm 区中的，Perm 区和正常的 JAVA Heap 区域是完全分开的。使用引号声明的字符串都是会直接在字符串常量池中生成，而 new 出来的 String 对象是放在 JAVA Heap 区域。所以拿一个 JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不相同的，即使调用<code>String.intern</code>方法也是没有任何关系的。</p>
<h3 id="2、jdk7"><a href="#2、jdk7" class="headerlink" title="2、jdk7"></a>2、jdk7</h3><ul>
<li>先看 s3和s4字符串。String s3 = new String(“1”) + new String(“1”);，这句代码中现在生成了2最终个对象，是字符串常量池中的“1” 和 JAVA Heap 中的 s3引用指向的对象。中间还有2个匿名的new String(“1”)我们不去讨论它们。此时s3引用对象内容是”11”，但此时常量池中是没有 “11”对象的。</li>
<li>接下来s3.intern();这一句代码，是将 s3中的“11”字符串放入 String 常量池中，因为此时常量池中不存在“11”字符串，因此常规做法是跟 jdk6 图中表示的那样，在常量池中生成一个 “11” 的对象，关键点是 jdk7 中常量池不在 Perm 区域了，这块做了调整。常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用指向 s3 引用的对象。 也就是说引用地址是相同的。</li>
<li>最后String s4 = “11”; 这句代码中”11”是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向 s3 引用对象的一个引用。所以 s4 引用就指向和 s3 一样了。因此最后的比较 s3 == s4 是 true。</li>
<li>再看 s 和 s2 对象。 String s = new String(“1”); 第一句代码，生成了2个对象。常量池中的“1” 和 JAVA Heap 中的字符串对象。s.intern(); 这一句是 s 对象去常量池中寻找后发现 “1” 已经在常量池里了。</li>
<li>接下来String s2 = “1”; 这句代码是生成一个 s2的引用指向常量池中的“1”对象。 结果就是 s 和 s2 的引用地址明显不同。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Redis性能</title>
    <url>/Redis%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h1 id="Redis性能"><a href="#Redis性能" class="headerlink" title="Redis性能"></a>Redis性能</h1><a id="more"></a>
<h2 id="一、Redis-内部的阻塞式操作"><a href="#一、Redis-内部的阻塞式操作" class="headerlink" title="一、Redis 内部的阻塞式操作"></a>一、Redis 内部的阻塞式操作</h2><p>Redis 的网络 IO 和键值对读写是由主线程完成的。那么，如果在主线程上执行的操作消耗的时间太长，就会引起主线程阻塞。</p>
<h3 id="1-1-和客户端交互时的阻塞点"><a href="#1-1-和客户端交互时的阻塞点" class="headerlink" title="1.1 和客户端交互时的阻塞点"></a>1.1 和客户端交互时的阻塞点</h3><ol>
<li><strong>集合全量查询和聚合操作</strong>。Redis 中涉及集合的操作复杂度通常为 O(N)，复杂度高的增删改查操作肯定会阻塞 Redis。</li>
<li><strong>bigkey 删除操作</strong>。删除操作的本质是要释放键值对占用的内存空间，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。</li>
<li><strong>清空数据库</strong>。</li>
</ol>
<h3 id="1-2-和磁盘交互时的阻塞点"><a href="#1-2-和磁盘交互时的阻塞点" class="headerlink" title="1.2 和磁盘交互时的阻塞点"></a>1.2 和磁盘交互时的阻塞点</h3><p><strong>AOF 日志同步写</strong>。Redis 采用子进程的方式生成 RDB 快照文件，以及执行 AOF 日志重写操作。这样一来，这两个操作由子进程负责执行，慢速的磁盘 IO 就不会阻塞主线程了。但如果AOF使用同步写回策略。就会阻塞主线程了。</p>
<h3 id="1-3-主从节点交互时的阻塞点"><a href="#1-3-主从节点交互时的阻塞点" class="headerlink" title="1.3 主从节点交互时的阻塞点"></a>1.3 主从节点交互时的阻塞点</h3><p><strong>加载 RDB 文件</strong>。在主从集群中，主库需要生成 RDB 文件，并传输给从库。主库在复制的过程中，创建和传输 RDB 文件都是由子进程来完成的，不会阻塞主线程。但从库接收到RDB 文件后，需要<strong>清空当前数据库</strong>，还需要<strong>把 RDB 文件加载到内存</strong>。</p>
<h2 id="二、CPU-核和-NUMA-架构的影响"><a href="#二、CPU-核和-NUMA-架构的影响" class="headerlink" title="二、CPU 核和 NUMA 架构的影响"></a>二、CPU 核和 NUMA 架构的影响</h2><h3 id="2-1-常见CPU-结构"><a href="#2-1-常见CPU-结构" class="headerlink" title="2.1 常见CPU 结构"></a>2.1 常见CPU 结构</h3><p><img src="/Redis性能/cpu常见结构.jpg" alt="cpu常见结构"></p>
<p>一个 CPU 处理器中一般有多个运行核心，我们把一个运行核心称为一个物理核，每个物理核都可以运行应用程序，每个物理核通常都会运行两个超线程，也叫作逻辑核。每个物理核都拥有私有的一级缓存（Level 1 cache，简称 L1 cache），包括一级指令缓存和一级数据缓存，以及私有的二级缓存（Level 2 cache，简称 L2 cache）。不同的物理核还会共享一个共同的三级缓存（Level 3 cache，简称为 L3 cache）。</p>
<p>服务器上通常还会有多个 CPU 处理器（也称为多 CPU Socket），每个处理器有自己的物理核（包括 L1、L2 缓存），L3 缓存，以及连接的内存，同时，不同处理器间通过总线连接。</p>
<ul>
<li>L1、L2 缓存中的指令和数据的访问速度很快，所以，充分利用 L1、L2 缓存，可以有效缩短应用程序的执行时间；</li>
<li>在 NUMA 架构下，如果应用程序从一个 Socket 上调度到另一个 Socket 上，就可能会出现远端内存访问的情况，这会直接增加应用程序的执行时间。</li>
</ul>
<h3 id="2-2-CPU-多核对-Redis-性能的影响"><a href="#2-2-CPU-多核对-Redis-性能的影响" class="headerlink" title="2.2 CPU 多核对 Redis 性能的影响"></a>2.2 CPU 多核对 Redis 性能的影响</h3><p>如果在 CPU 多核场景下，Redis 实例被频繁调度到不同 CPU 核上运行的话，对 Redis 实例的请求处理时间影响较大了。每调度一次，一些请求就会受到运行时信息、指令和数据重新加载过程的影响，这就会导致某些请求的延迟明显高于其他请求。</p>
<p>要避免 Redis 总是在不同 CPU 核上来回调度执行，我们可以把 Redis 实例和 CPU 核绑定了，让一个 Redis 实例固定运行在一个 CPU 核上。我们可以使用 taskset 命令把一个程序绑定在一个核上运行。</p>
<p><strong>在 CPU 多核的环境下，通过绑定 Redis 实例和 CPU 核，可以有效提高 Redis 的性能。</strong></p>
<h3 id="2-3-NUMA-架构对-Redis-性能的影响"><a href="#2-3-NUMA-架构对-Redis-性能的影响" class="headerlink" title="2.3 NUMA 架构对 Redis 性能的影响"></a>2.3 NUMA 架构对 Redis 性能的影响</h3><p>在 CPU 的 NUMA 架构下，当网络中断处理程序、Redis 实例分别和 CPU 核绑定后，就会有一个潜在的风险：<strong>如果网络中断处理程序和 Redis 实例各自所绑的 CPU 核不在同一个 CPU Socket 上，那么，Redis 实例读取网络数据时，就需要跨 CPU Socket 访问内存，这个过程会花费较多时间</strong>。</p>
<p><strong>为了避免 Redis 跨 CPU Socket 访问网络数据，我们最好把网络中断程序和 Redis 实例绑在同一个 CPU Socket 上。</strong></p>
<h3 id="2-4-绑核的风险和解决方案"><a href="#2-4-绑核的风险和解决方案" class="headerlink" title="2.4 绑核的风险和解决方案"></a>2.4 绑核的风险和解决方案</h3><p>当我们把 Redis 实例绑到一个 CPU 逻辑核上时，就会导致子进程、后台线程和 Redis 主线程竞争 CPU 资源，一旦子进程或后台线程占用 CPU 时，主线程就会被阻塞，导致 Redis 请求延迟增加。</p>
<ol>
<li><strong>一个 Redis 实例对应绑一个物理核</strong>。可以在一定程度上缓解 CPU 资源竞争，但它们相互之间的 CPU 竞争仍然还会存在。</li>
<li><strong>优化 Redis 源码，把子进程和后台线程绑到不同的 CPU 核上</strong>。</li>
</ol>
<h2 id="三、Redis-内存碎片"><a href="#三、Redis-内存碎片" class="headerlink" title="三、Redis 内存碎片"></a>三、Redis 内存碎片</h2><p>Redis 是内存数据库，内存利用率的高低直接关系到 Redis 运行效率的高低。为了让用户能监控到实时的内存使用情况，Redis 自身提供了 INFO 命令，可以用来查询内存使用的详细信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"><span class="meta">#</span><span class="bash"> Memory</span></span><br><span class="line">used_memory:1073741736</span><br><span class="line">used_memory_human:1024.00M</span><br><span class="line">used_memory_rss:1997159792</span><br><span class="line">used_memory_rss_human:1.86G</span><br><span class="line">…</span><br><span class="line">mem_fragmentation_ratio:1.86</span><br></pre></td></tr></table></figure>
<ul>
<li><p>used_memory_rss 是操作系统实际分配给 Redis 的物理内存空间，里面就包含了碎片；</p>
</li>
<li><p>used_memory 是 Redis 为了保存数据实际申请使用的空间。</p>
</li>
<li>mem_fragmentation_ratio是used_memory_rss 和 used_memory 相除的结果，表示的就是 Redis 当前的内存碎片率</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础</title>
    <url>/Redis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><a id="more"></a>
<h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><p> <em>Redis</em>目前支持5种<em>数据类型</em>，分别是：</p>
<ul>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Hash（字典）</li>
<li>Set（集合）</li>
<li>Sorted Set（有序集合）</li>
</ul>
<p>底层数据结构一共有 6 种，分别是<strong>简单动态字符串</strong>、<strong>双向链表</strong>、<strong>压缩列表</strong>、<strong>哈希表</strong>、<strong>跳表</strong>和<strong>整数数组</strong>。</p>
<p><img src="/Redis基础/总结\redis\底层数据结构.jpg" alt="底层数据结构" style="zoom: 25%;"></p>
<h2 id="二、rehash"><a href="#二、rehash" class="headerlink" title="二、rehash"></a>二、rehash</h2><p>为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p>
<ol>
<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>
<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li>
<li>释放哈希表 1 的空间。</li>
</ol>
<blockquote>
<p>但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。</p>
</blockquote>
<p>为了避免阻塞，Redis 采用了<strong>渐进式 rehash</strong>。</p>
<p>在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。</p>
<h2 id="三、压缩列表"><a href="#三、压缩列表" class="headerlink" title="三、压缩列表"></a>三、压缩列表</h2><p>压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。</p>
<p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。</p>
<h2 id="四、跳表"><a href="#四、跳表" class="headerlink" title="四、跳表"></a>四、跳表</h2><p>跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位。当数据量很大时，跳表的查找复杂度就是 O(logN)。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存和数据库的数据一致性</title>
    <url>/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<h1 id="缓存和数据库的数据一致性"><a href="#缓存和数据库的数据一致性" class="headerlink" title="缓存和数据库的数据一致性"></a>缓存和数据库的数据一致性</h1><p>这里的“一致性”包含了两种情况：</p>
<ul>
<li>缓存中有数据，那么，缓存的数据值需要和数据库中的值相同；</li>
<li>缓存中本身没有数据，那么，数据库中的值必须是最新值。</li>
</ul>
<a id="more"></a>
<h2 id="一、读写缓存"><a href="#一、读写缓存" class="headerlink" title="一、读写缓存"></a>一、读写缓存</h2><p>对于读写缓存来说，如果要对数据进行增删改，就需要在缓存中进行，同时还要根据采取的写回策略，决定是否同步写回到数据库中。</p>
<ul>
<li>同步直写策略：写缓存时，也同步写数据库，缓存和数据库中的数据一致；</li>
<li>异步写回策略：写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库。使用这种策略时，如果数据还没有写回数据库，缓存就发生了故障，那么，此时，数据库就没有最新的数据了。</li>
</ul>
<p>所以，对于读写缓存来说，要想保证缓存和数据库中的数据一致，就要采用同步直写策略。</p>
<p>要在业务应用中使用事务机制，来保证缓存和数据库的更新具有原子性，也就是说，两者要不一起更新，要不都不更新，返回错误信息，进行重试。否则，我们就无法实现同步直写。</p>
<h2 id="二、只读缓存"><a href="#二、只读缓存" class="headerlink" title="二、只读缓存"></a>二、只读缓存</h2><p>对于只读缓存来说，</p>
<ul>
<li>数据新增，直接写入数据库；</li>
<li>数据删改时，就需要把只读缓存中的数据标记为无效。这样一来，应用后续再访问这些增删改的数据时，因为缓存中没有相应的数据，就会发生缓存缺失。此时，应用再从数据库中把数据读入缓存，这样后续再访问数据时，就能够直接从缓存中读取了。</li>
</ul>
<h3 id="2-1-新增数据"><a href="#2-1-新增数据" class="headerlink" title="2.1 新增数据"></a>2.1 新增数据</h3><p>如果是新增数据，数据会直接写到数据库中，不用对缓存做任何操作</p>
<h3 id="2-2-删改数据"><a href="#2-2-删改数据" class="headerlink" title="2.2 删改数据"></a>2.2 删改数据</h3><p>如果发生删改操作，应用既要更新数据库，也要在缓存中删除数据。这两个操作如果无法保证原子性，就会出现数据不一致问题了。</p>
<p><img src="/缓存和数据库的数据一致性/缓存一致性.jpg" alt="缓存一致性"></p>
<h4 id="2-2-1-重试机制"><a href="#2-2-1-重试机制" class="headerlink" title="2.2.1 重试机制"></a>2.2.1 重试机制</h4><p>可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。如果能够成功地删除或更新，我们就要把这些值从消息队列中去除，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了。</p>
<h4 id="2-2-2-延时双删"><a href="#2-2-2-延时双删" class="headerlink" title="2.2.2 延时双删"></a>2.2.2 延时双删</h4><p>在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间，再进行一次缓存删除操作。这样一来，其它线程读取数据时，会发现缓存缺失，所以会从数据库中读取最新值。因为这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，所以我们也把它叫做“延迟双删”。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存雪崩、缓存击穿和缓存穿透</title>
    <url>/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%92%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="缓存雪崩、缓存击穿和缓存穿透"><a href="#缓存雪崩、缓存击穿和缓存穿透" class="headerlink" title="缓存雪崩、缓存击穿和缓存穿透"></a>缓存雪崩、缓存击穿和缓存穿透</h1><p>缓存雪崩、缓存击穿和缓存穿透是缓存使用中的三个常见问题。这三个问题一旦发生，会导致大量的请求积压到数据库层。如果请求的并发量很大，就会导致数据库宕机或是故障。</p>
<a id="more"></a>
<h2 id="一、缓存雪崩"><a href="#一、缓存雪崩" class="headerlink" title="一、缓存雪崩"></a>一、缓存雪崩</h2><p>缓存雪崩是指大量的应用请求无法在 Redis 缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。</p>
<h3 id="1-1-缓存中有大量数据同时过期"><a href="#1-1-缓存中有大量数据同时过期" class="headerlink" title="1.1 缓存中有大量数据同时过期"></a>1.1 缓存中有大量数据同时过期</h3><p>如果在某一个时刻，大量数据同时过期，应用再访问这些数据的话，就会把请求发送给数据库，从数据库中读取数据。如果应用的并发请求量很大，那么数据库的压力也就很大。</p>
<ol>
<li>设置过期时间时，增加一个较小的随机数</li>
<li>服务降级，是指发生缓存雪崩时，针对不同的数据采取不同的处理方式：<ul>
<li>当业务应用访问的是非核心数据时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息；</li>
<li>当业务应用访问的是核心数据时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。</li>
</ul>
</li>
</ol>
<h3 id="1-2-Redis-缓存实例发生故障"><a href="#1-2-Redis-缓存实例发生故障" class="headerlink" title="1.2 Redis 缓存实例发生故障"></a>1.2 Redis 缓存实例发生故障</h3><p>Redis 缓存实例发生故障宕机了，无法处理请求，这就会导致大量请求一下子积压到数据库层，从而发生缓存雪崩。</p>
<ol>
<li>在业务系统中实现服务熔断或请求限流机制</li>
<li>事前预防，通过主从节点的方式构建 Redis 缓存高可靠集群</li>
</ol>
<h2 id="二、缓存击穿"><a href="#二、缓存击穿" class="headerlink" title="二、缓存击穿"></a>二、缓存击穿</h2><p>缓存击穿是指，针对某个访问非常频繁的热点数据的请求，无法在缓存中进行处理，紧接着，访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力激增。</p>
<ol>
<li>对于访问特别频繁的热点数据，不设置过期时间。</li>
</ol>
<h2 id="三、缓存穿透"><a href="#三、缓存穿透" class="headerlink" title="三、缓存穿透"></a>三、缓存穿透</h2><p>缓存穿透是指要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。此时，应用也无法从数据库中读取数据再写入缓存，如果应用持续有大量请求访问数据，就会同时给缓存和数据库带来巨大压力。</p>
<ol>
<li>缓存空值或缺省值。应用再进行查询时，就可以直接从 Redis 中读取空值或缺省值，返回给业务应用了，避免了把大量请求发送给数据库处理，保持了数据库的正常运行。</li>
<li>使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据同步</title>
    <url>/Redis%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="Redis数据同步"><a href="#Redis数据同步" class="headerlink" title="Redis数据同步"></a>Redis数据同步</h1><p>Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。</p>
<ul>
<li>读操作：主库、从库都可以接收；</li>
<li>写操作：首先到主库执行，然后，主库将写操作同步给从库。</li>
</ul>
<a id="more"></a>
<h2 id="一、第一次同步"><a href="#一、第一次同步" class="headerlink" title="一、第一次同步"></a>一、第一次同步</h2><p>当我们启动多个 Redis 实例的时候，就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。</p>
<ol>
<li>第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。<ul>
<li>runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。</li>
<li>offset，此时设为 -1，表示第一次复制。</li>
</ul>
</li>
<li>第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会<strong>先清空当前数据库</strong>，然后加载 RDB 文件。</li>
<li>第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。</li>
</ol>
<blockquote>
<p>在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。</p>
</blockquote>
<h2 id="二、主-从-从”模式分担全量复制时的主库压力"><a href="#二、主-从-从”模式分担全量复制时的主库压力" class="headerlink" title="二、主 - 从 - 从”模式分担全量复制时的主库压力"></a>二、主 - 从 - 从”模式分担全量复制时的主库压力</h2><p>如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程<strong>生成 RDB 文件</strong>，进行数据全量同步。fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。此外，<strong>传输 RDB 文件</strong>也会占用主库的网络带宽，同样会给主库的资源使用带来压力。</p>
<p>我们可以通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。简单来说，我们在部署主从集群的时候，可以手动选择一个从库（比如选择内存资源配置较高的从库），用于级联其他的从库。</p>
<p>一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为基于长连接的命令传播，可以避免频繁建立连接的开销。</p>
<h2 id="三、主从库增量同步"><a href="#三、主从库增量同步" class="headerlink" title="三、主从库增量同步"></a>三、主从库增量同步</h2><p>在 Redis 2.8 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。</p>
<p>从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步，只会把主从库网络断连期间主库收到的命令，同步给从库。</p>
<h3 id="3-1-repl-backlog-buffer缓冲区"><a href="#3-1-repl-backlog-buffer缓冲区" class="headerlink" title="3.1 repl_backlog_buffer缓冲区"></a>3.1 repl_backlog_buffer缓冲区</h3><p>当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。</p>
<p>repl_backlog_buffer 是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。</p>
<p>主从库的连接恢复之后，从库首先会给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库，主库会判断自己的 master_repl_offset 和 slave_repl_offset 之间的差距。在网络断连阶段，主库可能会收到新的写操作命令，所以，一般来说，master_repl_offset 会大于 slave_repl_offset。此时，主库只用把 master_repl_offset 和 slave_repl_offset 之间的命令操作同步给从库就行。</p>
<blockquote>
<p>因为 repl_backlog_buffer 是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。为了避免这一情况，我们可以调整 repl_backlog_size 这个参数。这个参数和所需的缓冲空间大小有关。</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis哨兵机制</title>
    <url>/Redis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Redis哨兵机制"><a href="#Redis哨兵机制" class="headerlink" title="Redis哨兵机制"></a>Redis哨兵机制</h1><p>在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制</p>
<a id="more"></a>
<h2 id="一、基本流程"><a href="#一、基本流程" class="headerlink" title="一、基本流程"></a>一、基本流程</h2><p>哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。</p>
<p>哨兵主要负责的就是三个任务：<strong>监控</strong>、<strong>选主（选择主库）</strong>和<strong>通知</strong>。</p>
<ol>
<li>监控是指哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。</li>
<li>主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。这一步完成后，现在的集群里就有了新主库。</li>
<li>在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。</li>
</ol>
<h2 id="二、主观下线和客观下线"><a href="#二、主观下线和客观下线" class="headerlink" title="二、主观下线和客观下线"></a>二、主观下线和客观下线</h2><p>哨兵机制通常会采用多实例组成的集群模式进行部署，这也被称为<strong>哨兵集群</strong>。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p>
<p>哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。在判断主库是否下线时，不能由一个哨兵说了算，只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“客观下线”。这个判断原则就是：少数服从多数，当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例（阈值可配）判断主库为“主观下线”，才能最终判定主库为“客观下线”。</p>
<h2 id="三、选主"><a href="#三、选主" class="headerlink" title="三、选主"></a>三、选主</h2><p>在多个从库中，先按照一定的筛选条件，把不符合条件的从库去掉。然后，我们再按照一定的规则，给剩下的从库逐个打分，将得分最高的从库选为新主库</p>
<h3 id="3-1-从库筛选"><a href="#3-1-从库筛选" class="headerlink" title="3.1 从库筛选"></a>3.1 从库筛选</h3><ol>
<li>一般情况下，我们肯定要先保证所选的从库仍然在线运行。</li>
<li>除了要检查从库的当前在线状态，还要判断它之前的网络连接状态。如果在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从库的网络状况不好，不适合作为新主库。</li>
</ol>
<h3 id="3-2-从库打分"><a href="#3-2-从库打分" class="headerlink" title="3.2 从库打分"></a>3.2 从库打分</h3><ol>
<li><p>优先级最高的从库得分高。用户可以通过 slave-priority 配置项，给不同的从库设置不同优先级。</p>
</li>
<li><p>和旧主库同步程度最接近的从库得分高。</p>
<p>主从库同步时主库会用 master_repl_offset 记录当前的最新写操作在 repl_backlog_buffer 中的位置，而从库会用 slave_repl_offset 这个值记录当前的复制进度。从库的 slave_repl_offset 最接近 master_repl_offset，那么它的得分就最高，可以作为新主库。</p>
</li>
<li><p>ID 号小的从库得分高。</p>
<p>每个实例都会有一个 ID，这个 ID 就类似于这里的从库的编号。目前，Redis 在选主库时，有一个默认的规定：在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库。</p>
</li>
</ol>
<h2 id="四、基于-pub-sub-机制的哨兵集群组成"><a href="#四、基于-pub-sub-机制的哨兵集群组成" class="headerlink" title="四、基于 pub/sub 机制的哨兵集群组成"></a>四、基于 pub/sub 机制的哨兵集群组成</h2><h3 id="4-1-哨兵间的发现"><a href="#4-1-哨兵间的发现" class="headerlink" title="4.1 哨兵间的发现"></a>4.1 哨兵间的发现</h3><p>哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。</p>
<p>在主从集群中，主库上有一个名为“<strong>sentinel</strong>:hello”的频道，不同哨兵就是通过它来相互发现，实现互相通信的。</p>
<h3 id="4-2-哨兵发现从库"><a href="#4-2-哨兵发现从库" class="headerlink" title="4.2 哨兵发现从库"></a>4.2 哨兵发现从库</h3><p>哨兵向主库发送 INFO 命令来完成的，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。</p>
<h2 id="五、基于-pub-sub-机制的客户端事件通知"><a href="#五、基于-pub-sub-机制的客户端事件通知" class="headerlink" title="五、基于 pub/sub 机制的客户端事件通知"></a>五、基于 pub/sub 机制的客户端事件通知</h2><p>哨兵就是一个运行在特定模式下的 Redis 实例，只不过它并不服务请求操作，只是完成监控、选主和通知的任务。所以，每个哨兵实例也提供 pub/sub 机制，客户端可以从哨兵订阅消息。哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。</p>
<h2 id="六、哨兵Leader选举"><a href="#六、哨兵Leader选举" class="headerlink" title="六、哨兵Leader选举"></a>六、哨兵Leader选举</h2><p>任何一个实例只要自身判断主库“主观下线”后，就会给其他实例发送 is-master-down-by-addr 命令。接着，其他实例会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。</p>
<p>一个哨兵获得了仲裁所需的赞成票数后，就可以标记主库为“客观下线”。这个所需的赞成票数是通过哨兵配置文件中的 quorum 配置项设定的。</p>
<p>此时，这个哨兵就可以再给其他哨兵发送命令，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。这个投票过程称为“Leader 选举”。因为最终执行主从切换的哨兵称为 Leader，投票过程就是确定 Leader。在投票过程中，任何一个想成为 Leader 的哨兵，要满足两个条件：</p>
<ul>
<li>第一，拿到半数以上的赞成票；</li>
<li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redoLog和binLog日志</title>
    <url>/redoLog%E5%92%8CbinLog%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="redoLog和binLog日志"><a href="#redoLog和binLog日志" class="headerlink" title="redoLog和binLog日志"></a>redoLog和binLog日志</h1><a id="more"></a>
<h2 id="一、redo-log（重做日志）"><a href="#一、redo-log（重做日志）" class="headerlink" title="一、redo log（重做日志）"></a>一、redo log（重做日志）</h2><p>如果每一次的数据库更新操作都需要写进磁盘，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 使用了 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。</p>
<p>在同一个事务中，每当数据库进行修改数据操作时将修改结果更新到内存后，会在redo log添加一行记录记录“需要在哪个数据页上做什么修改”，并将该记录状态置为prepare，等到commit提交事务后，会将此次事务中在redo log添加的记录的状态都置为commit状态，之后将修改落盘时，会将redo log中状态为commit的记录的修改都写入磁盘。</p>
<p>InnoDB 的 redo log 是固定大小的循环存储，从头开始写，写到末尾就又回到开头循环写，当写满时，也会进行操作的更新以擦除redo log中的一些记录。</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>。</p>
<h3 id="1、作用："><a href="#1、作用：" class="headerlink" title="1、作用："></a>1、作用：</h3><p>确保事务的持久性。防止在发生故障的时间点，尚有数据未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p>
<h3 id="2、内容："><a href="#2、内容：" class="headerlink" title="2、内容："></a>2、内容：</h3><p>物理格式的日志，记录的是物理数据页面的修改的信息。</p>
<h3 id="3、产生时机："><a href="#3、产生时机：" class="headerlink" title="3、产生时机："></a>3、产生时机：</h3><p>事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入。</p>
<h3 id="4、释放时机："><a href="#4、释放时机：" class="headerlink" title="4、释放时机："></a>4、释放时机：</h3><p>当对应事务的数据写入到磁盘之后，redo log的使命也就完成了，日志占用的空间就可以重用（被覆盖）。</p>
<h3 id="5、redo-log写文件流程"><a href="#5、redo-log写文件流程" class="headerlink" title="5、redo log写文件流程"></a>5、redo log写文件流程</h3><p>redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。</p>
<p>MySQL支持用户自定义在commit时如何将log buffer中的日志刷log file中。这种控制通过变量innodb_flush_log_at_trx_commit 的值来决定。该变量有3种值：0、1、2，默认为1。但注意，这个变量只是控制commit动作是否刷新log buffer到磁盘。</p>
<ul>
<li>当设置为1的时候，事务每次提交都会将log buffer中的日志写入os buffer并调用fsync()刷到log file on disk中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差。</li>
<li>当设置为0的时候，事务提交时不会将log buffer中日志写入到os buffer，而是每秒写入os buffer并调用fsync()写入到log file on disk中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。</li>
<li>当设置为2的时候，每次提交都仅写入到os buffer，然后是每秒调用fsync()将os buffer中的日志写入到log file on disk。</li>
</ul>
<h2 id="二、binlog（归档日志）"><a href="#二、binlog（归档日志）" class="headerlink" title="二、binlog（归档日志）"></a>二、binlog（归档日志）</h2><p>binlog是Mysql sever层维护的一种二进制日志，与innodb引擎中的redo/undo log是完全不同的日志；其主要是用来记录对mysql数据更新或潜在发生更新的SQL语句，并以”事务”的形式保存在磁盘中；</p>
<h3 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h3><ul>
<li>复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves并回放来达到master-slave数据一致的目的</li>
<li>基于时间点的数据恢复</li>
<li>增量备份</li>
</ul>
<h3 id="2、内容：-1"><a href="#2、内容：-1" class="headerlink" title="2、内容："></a>2、内容：</h3><p>逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。</p>
<h3 id="3、产生时机：-1"><a href="#3、产生时机：-1" class="headerlink" title="3、产生时机："></a>3、产生时机：</h3><p>事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。</p>
<h3 id="4、释放时机：-1"><a href="#4、释放时机：-1" class="headerlink" title="4、释放时机："></a>4、释放时机：</h3><p>binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</p>
<h2 id="三、数据更新提交流程"><a href="#三、数据更新提交流程" class="headerlink" title="三、数据更新提交流程"></a>三、数据更新提交流程</h2><p><img src="/redoLog和binLog日志/更新流程.png" alt="更新流程"></p>
<h2 id="四、事务恢复"><a href="#四、事务恢复" class="headerlink" title="四、事务恢复"></a>四、事务恢复</h2><p><img src="/redoLog和binLog日志/事务恢复.png" alt="事务恢复" style="zoom: 67%;"></p>
<p>在MySQL启动后<br>1、初始化存储引擎，如本例中的InnoDB引擎<br>2、InnoDB引擎层读取redolog进行InnoDB层的故障恢复，回滚未prepared和commit的事务，但对于已经prepared，但未commit的事务，暂时挂起，保存到一个链表中，等待后续读取binlog日志，根据binlog日志再对这部分prepared的事务进行处理。<br>3、接下来，MySQL会读取最后一个binlog文件。通过文件头上是否存在标记LOG_EVENT_BINLOG_IN_USE_F，判定上次MySQL是正常关闭还是异常关闭，如果是异常关闭，则会进入故障恢复过程。<br>4、进入故障恢复过程后，会依次读取最后一个binlog文件中的所有log event，并将所有已提交事务的binlog日志中记录的xid提取出来添加到hash表中，以备后续对前述InnoDB故障恢复后遗留的Prepared事务继续处理。另外此处还要定位最后一个完整事务的位置，防止在上次系统异常关闭时有部分binlog日志未刷到磁盘上，即存在写了一半的binlog事务日志，这部分写了一半binlog日志的事务在MySQL中会按事务未提交来处理，后续会将其在存储引擎层回滚。<strong>当此文件中的内容全部读出之后，一是得到一个已提交事务的列表，另一个是最后一个完整事务的位置。</strong><br>5、然后检查由InnoDB层得到的Prepared事务列表，若Prepared事务在从Binlog中得到的提交事务列表中，则在InnoDB层提交此事务，否则回滚此事务。<br>6、最后MySQL将最后一个完整事务位置之后的binlog清除，完成故障恢复全部过程。</p>
]]></content>
  </entry>
  <entry>
    <title>Sql语句执行过程</title>
    <url>/Sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Sql语句执行过程"><a href="#Sql语句执行过程" class="headerlink" title="Sql语句执行过程"></a>Sql语句执行过程</h1><p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p>
<ul>
<li><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
</li>
<li><p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>
</li>
</ul>
<p><img src="/Sql语句执行过程/mysql逻辑架构.png" alt="mysql逻辑架构" style="zoom:33%;"></p>
<a id="more"></a>
<h2 id="一、连接器"><a href="#一、连接器" class="headerlink" title="一、连接器"></a>一、连接器</h2><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</p>
<blockquote>
<p>一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p>
</blockquote>
<h3 id="1、连接管理"><a href="#1、连接管理" class="headerlink" title="1、连接管理"></a>1、连接管理</h3><p>可以使用 show processlist 命令查看已有连接状态，如果连接长时间误操作，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p>
<h3 id="2、长链接使用"><a href="#2、长链接使用" class="headerlink" title="2、长链接使用"></a>2、长链接使用</h3><p>使用长连接后，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大。</p>
<p>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 <strong>mysql_reset_connection</strong> 可以重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p>
<h2 id="二、查询缓存"><a href="#二、查询缓存" class="headerlink" title="二、查询缓存"></a>二、查询缓存</h2><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。</p>
<p><strong>但是大多数情况下不建议使用查询缓存，因为查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空</strong></p>
<blockquote>
<p>MySQL 8.0 版本直接将查询缓存功能删掉了</p>
</blockquote>
<h2 id="三、分析器"><a href="#三、分析器" class="headerlink" title="三、分析器"></a>三、分析器</h2><h3 id="1、词法分析"><a href="#1、词法分析" class="headerlink" title="1、词法分析"></a>1、词法分析</h3><p>分析器先会做“词法分析”。MySQL 需要识别出Sql语句里面的字符串分别是什么，代表什么，比如表名、列名等</p>
<h3 id="2、语法分析、"><a href="#2、语法分析、" class="headerlink" title="2、语法分析、"></a>2、语法分析、</h3><p>根据词法分析的结果，语法分析器会根据语法规则，判断输入的 SQL 语句是否满足 MySQL 语法</p>
<h2 id="四、优化器"><a href="#四、优化器" class="headerlink" title="四、优化器"></a>四、优化器</h2><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p>
<h2 id="五、执行器"><a href="#五、执行器" class="headerlink" title="五、执行器"></a>五、执行器</h2><p>开始执行的时候，要先判断一下你对这个表有没有执行查询的权限，如果没有，就会返回没有权限的错误，如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>
]]></content>
  </entry>
  <entry>
    <title>正则化与范数</title>
    <url>/%E6%AD%A3%E5%88%99%E5%8C%96%E4%B8%8E%E8%8C%83%E6%95%B0/</url>
    <content><![CDATA[<h1 id="正则化与范数"><a href="#正则化与范数" class="headerlink" title="正则化与范数"></a>正则化与范数</h1><a id="more"></a>
<h2 id="一、正则化"><a href="#一、正则化" class="headerlink" title="一、正则化"></a>一、正则化</h2><p>正则化是结构风险最小化策略的实现，其在经验风险上加上一个正则化项。正则化项一般为模型复杂度的单调递增函数，模型越复杂，正则化值就越大。比如，正则化项可以是模型参数向量的范数。一般具有如下形式：<br>$$<br>\min_{f}\frac{1}{N}\sum_{i=1}^{N}L\left ( y_i,f\left ( x_i\right )\right )+\lambda J\left ( f\right )<br>$$<br>其中，第一项是经验风险，第二项是正则化项，$\lambda\geqslant 0$为调整两者之间关系的系数。</p>
<h2 id="二、范数"><a href="#二、范数" class="headerlink" title="二、范数"></a>二、范数</h2><p>不同范数对应的曲线如下图：</p>
<p><img src="/正则化与范数/范数图像.jpg" alt="范数图像" style="zoom: 50%;"></p>
<p>q越小，曲线越贴近坐标轴；q越大，曲线越远离坐标轴，并且棱角越明显。那么 q=0时极限逼近于十字架， 和 q=oo时极限逼近正方形。</p>
<p>q大于1，q范数为凸函数；q小于1，q范数不为凸函数。范数的凸性对求解最优化问题很重要。</p>
<h2 id="三、范数与正则化"><a href="#三、范数与正则化" class="headerlink" title="三、范数与正则化"></a>三、范数与正则化</h2><p>以1范数和2范数为例：</p>
<p><img src="/正则化与范数/范数图像1.jpg" alt="范数图像1" style="zoom: 50%;"></p>
<p>蓝色的圆圈表示原问题可能的解范围，橘色的表示正则项可能的解范围。而整个目标函数（原问题+正则项）有解当且仅当两个解范围相切。</p>
<p>从上图可以很容易地看出，由于2范数解范围是圆，所以相切的点有很大可能不在坐标轴上，而由于1范数是菱形（顶点是凸出来的），其相切的点更可能在坐标轴上，而坐标轴上的点有一个特点，其只有一个坐标分量不为零，其他坐标分量为零，即是稀疏的。</p>
<h3 id="1、L0范数"><a href="#1、L0范数" class="headerlink" title="1、L0范数"></a>1、L0范数</h3><p>L0范数表示向量中非零元素的数量。如果用L0范数作为正则项，就是希望模型中大部分参数为零，实现稀疏。</p>
<p>但是在机器学习中，特征的维度往往很大，解L0范数又是NP-hard问题，所以在实际中不可行。</p>
<h3 id="2、L1范数"><a href="#2、L1范数" class="headerlink" title="2、L1范数"></a>2、L1范数</h3><p>L1范数表示向量中各个元素绝对值之和，也叫“系数规则算子”。L1范数也可实现稀疏，且为L0的最优凸近似，比L0更易求解，所以实际稀疏模型中用L1范数约束。</p>
<h3 id="3、L2范数"><a href="#3、L2范数" class="headerlink" title="3、L2范数"></a>3、L2范数</h3><p>L2范数表示向量中各个元素的平方和然后开方。L2范数作为正则项，可以使得模型的每一个参数都比较小，但与L1不同的是，不会为0；这样的模型抗干扰能力强，参数很小时，即使样本数据发生较大变化，对预测值的影响也会很有限。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>正则化</tag>
      </tags>
  </entry>
  <entry>
    <title>最小二乘法</title>
    <url>/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/</url>
    <content><![CDATA[<h1 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h1><p>线性回归中，预测输出 $f(x)$ 和真实输出 $y$ 之间的误差是关注的核心指标。这一误差是以均方误差来定义的。当线性回归的模型为二维平面上的直线时，均方误差就是预测输出和真实输出之间的欧几里得距离，也就是两点间向量的 L2 范数。而以使均方误差取得最小值为目标的模型求解方法就是最小二乘法，其表达式可以写成：<br>$$<br>\begin{aligned}<br>w^{*}&amp;= \mathop{\arg\min_{w}}\sum_{k=1}{\left ( w^{T}x_{k}-y_{k}\right )}^{2}\\<br>&amp;=\mathop{\arg\min_{w}}\sum_{k=1}{\left | y_{k}-w^{T}x_{k}\right |}^{2}<br>\end{aligned}<br>$$<br>式中每个 $x_k$ 代表训练集中的一个样本。</p>
<a id="more"></a>
<h2 id="一、为什么使均方误差最小化的参数就是和训练样本匹配的最优模型呢？"><a href="#一、为什么使均方误差最小化的参数就是和训练样本匹配的最优模型呢？" class="headerlink" title="一、为什么使均方误差最小化的参数就是和训练样本匹配的最优模型呢？"></a>一、为什么使均方误差最小化的参数就是和训练样本匹配的最优模型呢？</h2><p>这个问题可以从概率论的角度阐释。线性回归得到的是统计意义上的拟合结果，在单变量的情形下，可能每一个样本点都没有落在求得的直线上。</p>
<p>对这个现象的一种解释是回归结果可以完美匹配理想样本点的分布，但训练中使用的真实样本点是理想样本点和噪声叠加的结果，因而与回归模型之间产生了偏差，而每个样本点上噪声的取值就等于 $y_k−f\left (x_k\right )$。</p>
<p>假定影响样本点的噪声满足参数为 $\left (0,σ^2\right )$ 的正态分布，对参数 w 的推导可以用最大似然的方式进行，即在已知样本数据及其分布的条件下，找到使样本数据以最大概率出现的假设。</p>
<p>单个样本$\left (x_k, y_k\right )$ 出现的概率实际上就是噪声等于 $y_k−f\left (x_k\right )$ 的概率，而相互独立的所有样本同时出现的概率则是每个样本出现概率的乘积，其表达式可以写成<br>$$<br>p\left (x_1,x2, \cdots,x_k,\cdots|w \right )=\<br>\prod_{k}{\frac{1}{\sqrt{2\pi}\sigma }\exp\left [ -\frac{1}{2\sigma^2}\left ( y_k-w^Tx_k\right )^2\right ]}<br>$$</p>
<p>而最大似然估计的任务就是让以上表达式的取值最大化。出于计算简便的考虑，上面的乘积式可以通过取对数的方式转化成求和式，且取对数的操作并不会影响其单调性。经过换算后，上式的最大化就可以等效为 $\sum_{k=1}{\left ( y_{k}-w^{T}x_{k}\right )}^{2}$ 的最小化。</p>
<p>因此，<strong>对于单变量线性回归而言，在误差函数服从正态分布的情况下，从几何意义出发的最小二乘法与从概率意义出发的最大似然估计是等价的</strong>。</p>
<h2 id="二、多元线性回归的最优参数"><a href="#二、多元线性回归的最优参数" class="headerlink" title="二、多元线性回归的最优参数"></a>二、多元线性回归的最优参数</h2><p>多元线性回归中的参数 w 也可以用最小二乘法进行估计，其最优解同样用偏导数确定，但参与运算的元素从向量变成了矩阵。在理想的情况下，多元线性回归的最优参数为<br>$$<br>w^{*}=\left ( X^{T}X\right )^{-1}X^{T}y<br>$$<br>式中的 $X$ 是由所有样本 $x=(x_0,x_1,x_2,\cdots,x_n)$ 的转置共同构成的矩阵。但这一表达式只在矩阵 $(X^TX)$ 的逆矩阵存在时成立。在大量复杂的实际任务中，每个样本中属性的数目甚至会超过训练集中的样本总数，此时求出的最优解 $w^{∗}$ 就不是唯一的，解的选择将依赖于学习算法的归纳偏好。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>最小二乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>范数</title>
    <url>/%E8%8C%83%E6%95%B0/</url>
    <content><![CDATA[<h1 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h1><a id="more"></a>
<h2 id="一、向量范数"><a href="#一、向量范数" class="headerlink" title="一、向量范数"></a>一、向量范数</h2><h3 id="1、p-范数："><a href="#1、p-范数：" class="headerlink" title="1、p-范数："></a>1、p-范数：</h3><p>$$<br>{\left \| X\right \|_p}=\left ( \sum_{i=1}^{N}\left | x_i\right |^{p}\right )^{\frac{1}{p}}<br>$$</p>
<p>即向量元素绝对值的$p$次方和的$1/p$次幂。</p>
<h2 id="2、1-范数："><a href="#2、1-范数：" class="headerlink" title="2、1-范数："></a>2、1-范数：</h2><p>$$<br>{\left \| X\right \|_1}= \sum_{i=1}^{N}\left | x_i\right |<br>$$</p>
<p>即向量元素绝对值之和。</p>
<h2 id="3、2-范数："><a href="#3、2-范数：" class="headerlink" title="3、2-范数："></a>3、2-范数：</h2><p>$$<br>{\left \| X\right \|_2}= \sqrt{\sum_{i=1}^{N} x_i^{2}}<br>$$</p>
<p>欧几里得范数，常用计算向量长度，即向量元素绝对值的平方和再开方。</p>
<h2 id="4、-infty-范数"><a href="#4、-infty-范数" class="headerlink" title="4、$\infty $-范数"></a>4、$\infty $-范数</h2><p>$$<br>\begin{aligned}<br>{\left \| X\right \|_{\infty }}&amp;=\left ( \sum_{i=1}^{N}\left | x_i\right |^{\infty }\right )^{\frac{1}{\infty }}\<br>&amp;=\max_{i}\left | x_i\right |<br>\end{aligned}<br>$$</p>
<p>即所有向量元素绝对值中的最大值。</p>
<h2 id="5、-infty-范数"><a href="#5、-infty-范数" class="headerlink" title="5、$-\infty $-范数"></a>5、$-\infty $-范数</h2><p>$$<br>\begin{aligned}<br>{\left \| X\right \|_{-\infty }}&amp;=\left ( \sum_{i=1}^{N}\left | x_i\right |^{-\infty }\right )^{\frac{1}{-\infty }}\<br>&amp;=\min_{i}\left | x_i\right |<br>\end{aligned}<br>$$</p>
<p>即所有向量元素绝对值中的最小值。</p>
<h2 id="二、矩阵范数"><a href="#二、矩阵范数" class="headerlink" title="二、矩阵范数"></a>二、矩阵范数</h2><h2 id="1、1-范数："><a href="#1、1-范数：" class="headerlink" title="1、1-范数："></a>1、1-范数：</h2><p>$$<br>{\left | A\right |_1}= \max_j\sum_{i=1}^{m}\left | a_{i,j}\right |<br>$$</p>
<p>列和范数，即所有矩阵列向量绝对值之和的最大值。</p>
<h2 id="2、2-范数："><a href="#2、2-范数：" class="headerlink" title="2、2-范数："></a>2、2-范数：</h2><p>$$<br>{\left | A\right |_2}= \sqrt{\lambda _{1}}<br>$$</p>
<p>谱范数，即$A^{T}A$矩阵的最大特征值的开平方。</p>
<h2 id="3、-infty-范数："><a href="#3、-infty-范数：" class="headerlink" title="3、$\infty $-范数："></a>3、$\infty $-范数：</h2><p>$$<br>{\left | A\right |_\infty }= \max_i\sum_{j=1}^{n}\left | a_{i,j}\right |<br>$$</p>
<p>行和范数，即所有矩阵行向量绝对值之和的最大值。</p>
<h2 id="4、F-范数："><a href="#4、F-范数：" class="headerlink" title="4、F-范数："></a>4、F-范数：</h2><p>$$<br>{\left \| A\right \|_F }= \left ( \sum_{i=1}^{m}\sum_{j=1}^{n}\left | a_{i,j}\right |^2\right )^{\frac{1}{2}}<br>$$</p>
<p>Frobenius范数，即矩阵元素绝对值的平方和再开平方。</p>
<h2 id="5、核范数："><a href="#5、核范数：" class="headerlink" title="5、核范数："></a>5、核范数：</h2><p>$$<br>{\left \| X\right \|_* }=  \sum_{i=1}^{n}\lambda _{i},\lambda _{i}是A的奇异值<br>$$</p>
<p>即奇异值之和。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>范数</tag>
      </tags>
  </entry>
  <entry>
    <title>tf.summary</title>
    <url>/tf-summary/</url>
    <content><![CDATA[<h1 id="tf-summary"><a href="#tf-summary" class="headerlink" title="tf.summary"></a>tf.summary</h1><p>Summary是对网络中Tensor取值进行监测的一种<code>Operation</code>。这些操作在图中是“外围”操作，不影响数据流本身。<strong>Summary本身也是一个op</strong>。</p>
<a id="more"></a>
<h2 id="一、Tensorboard的数据形式"><a href="#一、Tensorboard的数据形式" class="headerlink" title="一、Tensorboard的数据形式"></a>一、Tensorboard的数据形式</h2><p>Tensorboard可以记录与展示以下数据形式：</p>
<ol>
<li>标量Scalars</li>
<li>图片Images</li>
<li>音频Audio</li>
<li>计算图Graph</li>
<li>数据分布Distribution</li>
<li>直方图Histograms</li>
<li>嵌入向量Embeddings</li>
</ol>
<h2 id="二、记录方法"><a href="#二、记录方法" class="headerlink" title="二、记录方法"></a>二、记录方法</h2><h3 id="1、tf-summary-scalar"><a href="#1、tf-summary-scalar" class="headerlink" title="1、tf.summary.scalar"></a>1、tf.summary.scalar</h3><p>用来显示标量信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.summary.scalar(name, tensor, collections=<span class="keyword">None</span>, family=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2、tf-summary-image"><a href="#2、tf-summary-image" class="headerlink" title="2、tf.summary.image"></a>2、tf.summary.image</h3><p>输出带图像的probuf</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.summary.image(name, tensor, max_outputs=<span class="number">3</span>, collections=<span class="keyword">None</span>, family=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3、tf-summary-audio"><a href="#3、tf-summary-audio" class="headerlink" title="3、tf.summary.audio"></a>3、tf.summary.audio</h3><p>展示训练过程中记录的音频</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.summary.audio(name, tensor, sample_rate, max_outputs=<span class="number">3</span>, collections=<span class="keyword">None</span>, family=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4、tf-summary-histogram"><a href="#4、tf-summary-histogram" class="headerlink" title="4、tf.summary.histogram"></a>4、tf.summary.histogram</h3><p>用来显示直方图信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.summary.histogram(name, values, collections=<span class="keyword">None</span>, family=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<h2 id="三、输出方法"><a href="#三、输出方法" class="headerlink" title="三、输出方法"></a>三、输出方法</h2><h3 id="1、选取要展示的summary项"><a href="#1、选取要展示的summary项" class="headerlink" title="1、选取要展示的summary项"></a>1、选取要展示的summary项</h3><ul>
<li>tf.summary.merge_all  展示所有的summary项</li>
<li>tf.summary.merge([summary_op1, summary_op2…]) 展示指定summary项</li>
</ul>
<h3 id="2、定义-tf-summary-FileWriter"><a href="#2、定义-tf-summary-FileWriter" class="headerlink" title="2、定义 tf.summary.FileWriter"></a>2、定义 tf.summary.FileWriter</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.summary.FileWriter(logdir, </span><br><span class="line">		              graph=<span class="keyword">None</span>,</span><br><span class="line">           			  max_queue=<span class="number">10</span>,</span><br><span class="line">              		  flush_secs=<span class="number">120</span>,</span><br><span class="line">              		  graph_def=<span class="keyword">None</span>,</span><br><span class="line">              		  filename_suffix=<span class="keyword">None</span>,</span><br><span class="line">              		  session=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3、向FileWriter写入summary"><a href="#3、向FileWriter写入summary" class="headerlink" title="3、向FileWriter写入summary"></a>3、向FileWriter写入summary</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FileWriter.add_summary(summary, global_step=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4、示例代码"><a href="#4、示例代码" class="headerlink" title="4、示例代码"></a>4、示例代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ops</span></span><br><span class="line">loss = ...</span><br><span class="line">tf.summary.scalar(<span class="string">"loss"</span>, loss)</span><br><span class="line">merged_summary = tf.summary.merge_all()</span><br><span class="line"></span><br><span class="line">init = tf.global_variable_initializer()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  writer = tf.summary.FileWriter(your_dir, sess.graph)</span><br><span class="line">  sess.run(init)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">100</span>):</span><br><span class="line">    _,summary = sess.run([train_op,merged_summary], feed_dict)</span><br><span class="line">    writer.add_summary(summary, i)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者 (Builder) 模式，中文翻译为建造者模式或者构建者模式，也有人叫它生成器模式。</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>创建型</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark核心数据结构:弹性分布式数据集RDD</title>
    <url>/Spark%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BC%B9%E6%80%A7%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%9B%86RDD/</url>
    <content><![CDATA[<h1 id="Spark-核心数据结构：弹性分布式数据集-RDD"><a href="#Spark-核心数据结构：弹性分布式数据集-RDD" class="headerlink" title="Spark 核心数据结构：弹性分布式数据集 RDD"></a>Spark 核心数据结构：弹性分布式数据集 RDD</h1><a id="more"></a>]]></content>
      <categories>
        <category>spark</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark抽象和架构</title>
    <url>/Spark%E6%8A%BD%E8%B1%A1%E5%92%8C%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Spark抽象和架构"><a href="#Spark抽象和架构" class="headerlink" title="Spark抽象和架构"></a>Spark抽象和架构</h1><h2 id="一、Spark架构"><a href="#一、Spark架构" class="headerlink" title="一、Spark架构"></a>一、Spark架构</h2><p>Spark 往往作为统一资源管理平台的用户，向统一资源管理平台提交作业，作业提交成功后，Spark 的作业会被调度成计算任务，在资源管理系统的容器中运行。在集群运行中的 Spark 架构是典型的主从架构，如下面这张图所示。</p>
<p><img src="/Spark抽象和架构/spark架构.png" style="zoom:33%;"></p>
<a id="more"></a>
<p>我们先来看看 Spark 架构，在运行时，Driver 是主节点，而 Executor 是从节点，这 3 个 Executor 分别运行在资源管理系统中的 3 个容器中。</p>
<p>在 Spark 的架构中，Driver 主要负责作业调度工作，Executor 主要负责执行具体的作业计算任务，Driver 中的 SparkSession 组件，是 Spark 2.0 引入的一个新的组件，曾经我们熟悉的 SparkContext、SqlContext、HiveContext 都是 SparkSession 的成员变量。</p>
<p>因此，用户编写的 Spark 代码是从新建 SparkSession 开始的。其中 <strong>SparkContext 的作用是连接用户编写的代码与运行作业调度以及任务分发的代码</strong>。当用户提交作业启动一个 Driver 时，会通过 SparkContext 向集群发送命令，Executor 会遵照指令执行任务。一旦整个执行过程完成，Driver 就会结束整个作业。</p>
<p><img src="/Spark抽象和架构/spark架构2.png" alt="spark架构2" style="zoom:33%;"></p>
<p>上图更详细地描述了 Driver 与 Executor 之间的运行过程。</p>
<ul>
<li><p>首先，Driver 会根据用户编写的代码生成一个计算任务的有向无环图（Directed Acyclic Graph，DAG），这个有向无环图是 Spark 区别 Hadoop MapReduce 的重要特征；</p>
</li>
<li><p>接着，DAG 会根据 RDD（弹性分布式数据集，图中第 1 根虚线和第 2 根虚线中间的圆角方框）之间的依赖关系被 DAG Scheduler 切分成由 Task 组成的 Stage，这里的 Task 就是我们所说的计算任务，注意这个 Stage 不要翻译为阶段，这是一个专有名词，它表示的是一个计算任务的集合；</p>
</li>
<li><p>最后 TaskScheduler 会通过 ClusterManager 将 Task 调度到 Executor 上执行。</p>
</li>
</ul>
<p>可以看到，Spark 并不会直接执行用户编写的代码，而用户代码的作用只是告诉 Spark 要做什么，也就是一种“声明”。</p>
<h2 id="二、Spark抽象"><a href="#二、Spark抽象" class="headerlink" title="二、Spark抽象"></a>二、Spark抽象</h2><p>当用户编写好代码向集群提交时，一个作业就产生了，作业的英文是 job，在 YARN 中，则喜欢把作业叫 application。Driver 会根据用户的代码生成一个有向无环图，下面这张图就是根据用户逻辑生成的一个有向无环图。</p>
<p><img src="/Spark抽象和架构/spark抽象.png" alt="spark抽象" style="zoom:33%;"></p>
<p>通过这张图，可以大概看出计算逻辑：A 和 C 都是两张表，在分别进行分组聚合和筛选的操作后，做了一次 join 操作。</p>
<p>在上图中，灰色小方框就是我们所说的分区（partition），它和计算任务是一一对应的，也就是说，有多少个分区，就有多少个计算任务，显然的，一个作业，会有多个计算任务，这也是分布式计算的意义所在，我们可以通过设置分区数量来控制每个计算任务的计算量。在 DAG 中，每个计算任务的输入就是一个分区，一些相关的计算任务所构成的任务集合可以被看成一个 Stage，这里”相关”指的是某个标准，我们后面会讲到。RDD 则是分区的集合（图中 A、B、C、D、E），用户只需要操作 RDD 就可以构建出整个 DAG。</p>
<p>一个 Executor 同时只能执行一个计算任务，但一个 Worker（物理节点）上可以同时运行多个 Executor。Executor 的数量决定了同时处理任务的数量，一般来说，分区数远大于 Executor 数量才是合理的。所以同一个作业，在计算逻辑不变的情况下，分区数和 Executor 的数量很大程度上决定了作业运行的时间。</p>
]]></content>
      <categories>
        <category>spark</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>统一资源管理与调度系统</title>
    <url>/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="统一资源管理与调度系统"><a href="#统一资源管理与调度系统" class="headerlink" title="统一资源管理与调度系统"></a>统一资源管理与调度系统</h1><p>YARN 的全称是 Yet Another Resource Negotiator，直译过来是：另一种资源协调者，但是它的标准名称是统一资源管理与调度系统，这个名称比较抽象，当遇到这种抽象的名词时，我喜欢把概念拆开来看，那么这个名称一共包含 3 个词：统一、资源管理、调度。</p>
<a id="more"></a>
<h2 id="一、统一"><a href="#一、统一" class="headerlink" title="一、统一"></a>一、统一</h2><p>对于大数据计算框架来说，统一指的是资源并不会与计算框架绑定，<strong>对于所有计算框架来说，所有资源都是无差别的</strong>，也就是说这个系统可以支持多种计算框架。更广义上的统一，是指资源针对所有应用来说都是无差别的，包括长应用、短应用、数据库、后端服务，等等。</p>
<h2 id="二、资源管理"><a href="#二、资源管理" class="headerlink" title="二、资源管理"></a>二、资源管理</h2><p>对于资源管理来说，最重要的是了解对于这个系统，什么才是它的资源，或者说是资源的维度，常见的有 CPU、内存、磁盘、网络带宽等，<strong>对于 YARN 来说，资源的维度有两个：CPU 和内存</strong>。这也是大数据计算框架最需要的资源。</p>
<h2 id="三、调度"><a href="#三、调度" class="headerlink" title="三、调度"></a>三、调度</h2><p>目前的宏观调度机制一共有 3 种：集中式调度器（Monolithic Scheduler）、双层调度器（Two-Level Scheduler）和状态共享调度器（Shared-State Scheduler）</p>
<h3 id="1、集中式调度器（Monolithic-Scheduler）"><a href="#1、集中式调度器（Monolithic-Scheduler）" class="headerlink" title="1、集中式调度器（Monolithic Scheduler）"></a>1、集中式调度器（Monolithic Scheduler）</h3><p>集中式调度器全局只有一个中央调度器，计算框架的资源申请全部提交给中央调度器来满足，所有的调度逻辑都由中央调度器来实现。所以调度系统在高并发作业的情况下，容易出现性能瓶颈。</p>
<p>集中式调度器的实现就是 Hadoop MapReduce 的 JobTracker，实际的资源利用率只有 70% 左右，甚至更低。</p>
<h3 id="2、双层调度器（Two-Level-Scheduler）"><a href="#2、双层调度器（Two-Level-Scheduler）" class="headerlink" title="2、双层调度器（Two-Level Scheduler）"></a>2、双层调度器（Two-Level Scheduler）</h3><p>双层调度器将整个调度工作划分为两层：中央调度器和框架调度器。中央调度器管理集群中所有资源的状态，它拥有集群所有的资源信息，按照一定策略（例如 FIFO、Fair、Capacity、Dominant Resource Fair）将资源粗粒度地分配给框架调度器，各个框架调度器收到资源后再根据应用申请细粒度将资源分配给容器执行具体的计算任务。在这种双层架构中，每个框架调度器看不到整个集群的资源，只能看到中央调度器给自己的资源。</p>
<h3 id="3、状态共享调度器"><a href="#3、状态共享调度器" class="headerlink" title="3、状态共享调度器"></a>3、状态共享调度器</h3><p>状态共享调度器是由 Google 的 Omega 调度系统所提出的一种新范型。状态共享式调度大大弱化了中央调度器，它只需保存一份集群使用信息，取而代之的是各个框架调度器，每个调度器都能获取集群的全部信息，并采用乐观锁控制并发。</p>
<p>Omega 与双层调度器的不同在于严重弱化了中央调度器，每个框架内部会不断地从主调度器更新集群信息并保存一份，而框架对资源的申请则会在该份信息上进行，一旦框架做出决策，就会将该信息同步到主调度。资源竞争过程是通过事务进行的，从而保证了操作的原子性。由于决策是在自己的私有数据上做出的，并通过原子事务提交，系统保证只有一个胜出者，这是一种类似于 MVCC 的乐观并发机制，可以增加系统的整体并发性能，但是调度公平性有所不足。</p>
<h2 id="四、YARN的实现"><a href="#四、YARN的实现" class="headerlink" title="四、YARN的实现"></a>四、YARN的实现</h2><p>YARN 的架构是典型的主从架构，主节点是 ResourceManger，也是我们前面说的主调度器，所有的资源的空闲和使用情况都由 ResourceManager 管理。ResourceManager 也负责监控任务的执行，从节点是 NodeManager，主要负责管理 Container 生命周期，监控资源使用情况等 ，Container 是 YARN 的资源表示模型，Task 是计算框架的计算任务，会运行在 Container 中，ApplicationMaster 可以暂时认为是二级调度器，比较特殊的是它同样运行在 Container 中。</p>
<p><img src="/统一资源管理与调度系统/yarn架构.png" alt="yarn架构" style="zoom:50%;"></p>
<h3 id="YARN-启动作业的流程"><a href="#YARN-启动作业的流程" class="headerlink" title="YARN 启动作业的流程"></a>YARN 启动作业的流程</h3><p><img src="/统一资源管理与调度系统/yarn流程.png" alt="yarn流程" style="zoom:50%;"></p>
<p>第 1 步：客户端向 ResourceManager 提交自己的应用，这里的应用就是指 MapReduce 作业。<br>第 2 步：ResourceManager 向 NodeManager 发出指令，为该应用启动第一个 Container，并在其中启动 ApplicationMaster。<br>第 3 步：ApplicationMaster 向 ResourceManager 注册。<br>第 4 步：ApplicationMaster 采用轮询的方式向 ResourceManager 的 YARN Scheduler 申领资源。<br>第 5 步：当 ApplicationMaster 申领到资源后（其实是获取到了空闲节点的信息），便会与对应 NodeManager 通信，请求启动计算任务。<br>第 6 步：NodeManager 会根据资源量大小、所需的运行环境，在 Container 中启动任务。<br>第 7 步：各个任务向 ApplicationMaster 汇报自己的状态和进度，以便让 ApplicationMaster 掌握各个任务的执行情况。<br>第 8 步：应用程序运行完成后，ApplicationMaster 向 ResourceManager 注销并关闭自己。</p>
]]></content>
      <categories>
        <category>spark</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>信息论简介</title>
    <url>/%E4%BF%A1%E6%81%AF%E8%AE%BA%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="信息论简介"><a href="#信息论简介" class="headerlink" title="信息论简介"></a>信息论简介</h1><p>香农在《通信的数学理论》中开宗明义：“通信的基本问题是在一点精确地或近似地复现在另一点所选取的消息。消息通常有意义，即根据某种体系，消息本身指向或关联着物理上或概念上的特定实体。但消息的语义含义与工程问题无关，重要的问题是一条消息来自于一个所有可能的消息的集合。”</p>
<a id="more"></a>
<h2 id="一、信息熵"><a href="#一、信息熵" class="headerlink" title="一、信息熵"></a>一、信息熵</h2><p>信息论使用“信息熵”的概念，对单个信源的信息量和通信中传递信息的数量与效率等问题做出了解释，并在世界的不确定性和信息的可测量性之间搭建起一座桥梁。</p>
<p><strong>熵的本质即是一个系统内在的混乱程度。</strong></p>
<p>在信息论中，如果事件$A$ 发生的概率为 $p(A)$，则这个事件的自信息量的定义为<br>$$<br>h(A)=-log_{2}p(A)<br>$$<br>根据单个事件的自信息量可以计算包含多个符号的信源的信息熵。<strong>信源的信息熵是信源可能发出的各个符号的自信息量在信源构成的概率空间上的统计平均值</strong>。如果一个离散信源 $X$ 包含 $n$ 个符号，每个符号 $a_i$ 的取值为 $p(a_i)$，则 $X$ 的信源熵为<br>$$<br>H(X)=-\sum_{i=1}^{n} p\left(a_{i}\right) \log_{2} p\left(a_{i}\right)<br>$$<br>信源熵描述了信源每发送一个符号所提供的平均信息量，是信源总体信息测度的均值。当信源中的每个符号的取值概率相等时，信源熵取到最大值 $log_{2}n$，意味着信源的随机程度最高。</p>
<h2 id="二、条件熵"><a href="#二、条件熵" class="headerlink" title="二、条件熵"></a>二、条件熵</h2><p>在概率论中有条件概率的概念，将条件概率扩展到信息论中，就可以得到条件熵。如果两个信源之间具有相关性，那么在已知其中一个信源 $X$ 的条件下，另一个信源 $Y$ 的信源熵就会减小。条件熵 $H(Y∣X)$ 表示的是在已知随机变量 $X$ 的条件下另一个随机变量 $Y$ 的不确定性，也就是在给定 $X$ 时，根据 $Y$ 的条件概率计算出的熵再对 $X$ 求解数学期望：</p>
<p>$$<br>\begin{align}<br>H(Y | X)&amp;=\sum_{i=1}^{n} p\left(x_{i}\right) H\left(Y | X=x_{i}\right) \\<br>&amp;=-\sum_{i=1}^{n} p\left(x_{i}\right) \sum_{j=1}^{m} p\left(y_{j} | x_{i}\right) \log_{2} p\left(y_{j} | x_{i}\right) \\<br>&amp;=-\sum_{i=1}^{n} \sum_{j=1}^{m} p\left(x_{i}, y_{j}\right) \log_{2} p\left(y_{j} | x_{i}\right)<br>\end{align}<br>$$</p>
<p>条件熵的意义在于先按照变量 X 的取值对变量 Y 进行了一次分类，对每个分出来的类别计算其单独的信息熵，再将每个类的信息熵按照 X 的分布计算其数学期望。</p>
<h2 id="三、互信息"><a href="#三、互信息" class="headerlink" title="三、互信息"></a>三、互信息</h2><p>定义了条件信息熵后，就可以进一步得到互信息的概念<br>$$<br>I(X ; Y)=H(Y)-H(Y | X)<br>$$<br><strong>互信息等于 $Y$ 的信源熵减去已知 $X$ 时 $Y$ 的条件熵，即由 $X$ 提供的关于 $Y$ 的不确定性的消除，也可以看成是 $X$ 给 $Y$ 带来的信息增益</strong>。互信息这个名称在通信领域经常使用，信息增益则在机器学习领域中经常使用，两者的本质是一样的。</p>
<p>在机器学习中，信息增益常常被用于分类特征的选择。</p>
<p>对于给定的训练数据集 $Y$，$H(Y)$ 表示在未给定任何特征时，对训练集进行分类的不确定性；$H(Y∣X)$ 则表示了使用特征 $X$ 对训练集 $Y$ 进行分类的不确定性。信息增益表示的就是特征 $X$ 带来的对训练集 $Y$ 分类不确定性的减少程度，也就是特征 $X$ 对训练集 $Y$ 的区分度。显然，信息增益更大的特征具有更强的分类能力。但信息增益的值很大程度上依赖于数据集的信息熵 $H(Y)$，因而并不具有绝对意义。为解决这一问题，研究者又提出了信息增益比的概念，并将其定义为:<br>$$<br>g(X, Y)=I(X ; Y) / H(Y)<br>$$</p>
<h2 id="三、交叉熵"><a href="#三、交叉熵" class="headerlink" title="三、交叉熵"></a>三、交叉熵</h2><p>用分布 P 的最佳信息传递方式来传达分布 Q 中随机抽选的一个事件，所需的平均信息长度为交叉熵，表达为<br>$$<br>H_{P}(Q)=\int_{x} q(x) \log \frac{1}{p(x)} d x<br>$$</p>
<h2 id="四、Kullback-Leibler-散度"><a href="#四、Kullback-Leibler-散度" class="headerlink" title="四、Kullback-Leibler 散度"></a>四、Kullback-Leibler 散度</h2><p>另一个在机器学习中经常使用的信息论概念叫作“Kullback-Leibler 散度”，简称 KL 散度。<strong>KL 散度是描述两个概率分布 P 和 Q 之间的差异的一种方法</strong>。其表示用分布 Q 的最佳信息传递方式来传达分布 P，比用分布 P 自己的最佳信息传递方式来传达分布 P，平均多耗费的信息长度为 KL 散度，<strong>KL 散度是对额外信息量的衡量</strong>。其定义为<br>$$<br>\begin{align}<br>D_{K L}(P | Q)&amp;=H_{Q}(P)-H(P)\\<br>&amp;= \sum_{x} p(x) \log \frac{1}{q(x)}-\sum_{x} p(x) \log \frac{1}{p(x)}\\<br>&amp;=\sum_{i=1}^{n} p\left(x_{i}\right) \log_{2} \frac{p\left(x_{i}\right)}{q\left(x_{i}\right)}<br>\end{align}<br>$$</p>
<p>给定一个信源，其符号的概率分布为 $P(X)$，就可以设计一种针对 $P(X)$ 的最优编码，使得表示该信源所需的平均比特数最少（等于该信源的信源熵）。可是当信源的符号集合不变，而符合的概率分布变为 $Q(X)$ 时，再用概率分布 $P(X)$ 的最优编码对符合分布 $Q(X)$ 的符号编码，此时编码结果的字符数就会比最优值多一些比特。KL 散度就是用来衡量这种情况下平均每个字符多用的比特数，也可以表示两个分布之间的距离。</p>
<p>$D_{K L}(P | Q)$中涉及了两个分布</p>
<ul>
<li>要传达的信息来自分布P</li>
<li>信息传递方式由分布Q决定</li>
</ul>
<p>由 KL 散度的公式可知，分布 P 里可能性越大的事件，对$D_{K L}(P | Q)$ 影响力越大。如果想让$D_{K L}(P | Q)$尽量小，就要优先关注分布 P 里的常见事件（假设为 x），确保它们在分布 Q 里不是特别罕见。</p>
<p>因为一旦事件 x 在分布 Q 里罕见，意味着在设计分布 Q 的信息传递方式时，没有着重优化传递 x 的成本，传达事件 x 所需的成本，log(1/q(x)) 会特别大。所以，当这一套传递方式被用于传达分布 P 的时候，我们会发现，传达常见事件需要的成本特别大，整体成本也就特别大。类似地，想让 $D_{K L}(Q | P)$ 特别小，就要优先考虑分布 Q 里那些常见的事件了。</p>
<h2 id="五、KL散度的不对称性"><a href="#五、KL散度的不对称性" class="headerlink" title="五、KL散度的不对称性"></a>五、KL散度的不对称性</h2><p>假设存在一个真实分布 P，由两个高斯分布混合而成，用蓝线表示。</p>
<p><img src="/信息论简介/KL散度1.jpeg" alt="KL散度1" style="zoom: 33%;"></p>
<p>在不知道分布 P 的信息的情况下，我们做出了一个常见的假设：假设数据符合高斯分布。当我们尝试用一个普通的高斯分布 Q 来近似分布 P，换言之，尝试让 Q 尽量「贴近」P 的时候，可以选择的目标函数有：</p>
<p>$$<br>1、Q^{*}=\arg \min D_{K L}(P | Q)\\<br>2、Q^{*}=\arg \min D_{K L}(Q | P)<br>$$</p>
<p>选择不同的目标函数，会产生完全不同的 Q。</p>
<p><img src="/信息论简介/KL散度2.jpeg" alt="KL散度2" style="zoom:50%;"></p>
<p>1、如果我们选择目标函数 1，结果会像左图一样。在优化过程中，重要的是分布 P 中的<em>常见事件</em>，也就是蓝线的两峰，我们要优先确保它们在分布 Q 里不是特别罕见（信息长度不是特别长）。由于分布 P 里有两个峰值区域，分布 Q 无法偏向任何一个峰值，拉锯的结果是，Q 选择了横亘在分布 P 两个峰值中间。</p>
<p>2、如果我们选择目标函数 2，结果会像右图一样，重要的是分布 P 中的<em>罕见事件</em>（信息长度特别长的那些事件），也就是蓝线的谷底，我们优先确保它们在分布 Q 里不是特别常见。左图里那种，分布 Q 横亘在分布 P 两个峰值中间，是我们最不希望发生的、KL 散度格外大的情况。相反，只有一个峰值的分布 Q 最终会选择贴合分布 P 两个峰值区域中的任意一个。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>信息论</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。</p>
<a id="more"></a>
<p>通过一个例子来解释一下。<br>在下面代码中，根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class="line">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line">    IRuleConfigParser parser = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"json"</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"xml"</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"yaml"</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"properties"</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(</span><br><span class="line">             <span class="string">"Rule config file format is not supported: "</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String configText = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"json"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一、简单工厂"><a href="#一、简单工厂" class="headerlink" title="一、简单工厂"></a>一、简单工厂</h2><p>1、为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。</p>
<p>2、为了让类的职责更加单一、代码更加清晰，我们再进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class="line">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line">    <span class="comment">//通过简单工厂模式类创建对应的解析器</span></span><br><span class="line">    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(</span><br><span class="line">              <span class="string">"Rule config file format is not supported: "</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String configText = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"json"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单工厂模式类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title">createParser</span><span class="params">(String configFormat)</span> </span>&#123;</span><br><span class="line">    IRuleConfigParser parser = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 根据不同文件 生成不同的解析器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"json"</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"xml"</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"yaml"</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"properties"</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果我们要添加新的 parser，那么就需要改动 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？</p>
<ul>
<li>实际上，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的。</li>
</ul>
</blockquote>
<blockquote>
<p>除此之外，在 RuleConfigParserFactory 的实现中，有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？</p>
<ul>
<li>实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它<strong>虽然提高了代码的扩展性，更加符合开闭原则，但也增加了类的个数，牺牲了代码的可读性</strong>。</li>
</ul>
</blockquote>
<p>尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加 parser，也没有太多的 parser）是没有问题的。</p>
<h2 id="二、工厂方法"><a href="#二、工厂方法" class="headerlink" title="二、工厂方法"></a>二、工厂方法</h2><p>如果我们利用多态创建不同类型的工厂类，将 if 分支逻辑去掉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">IRuleConfigParser <span class="title">createParser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YamlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，<strong>工厂方法模式比起简单工厂模式更加符合开闭原则</strong>。<br>但这样在这些工厂类的使用上依然存在问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class="line">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line">    <span class="comment">// 根据不同文件 生成不同的解析器工厂类</span></span><br><span class="line">    IRuleConfigParserFactory parserFactory = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"json"</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> JsonRuleConfigParserFactory();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"xml"</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> XmlRuleConfigParserFactory();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"yaml"</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> YamlRuleConfigParserFactory();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"properties"</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> PropertiesRuleConfigParserFactory();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(<span class="string">"Rule config file format is not supported: "</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由解析器工厂类生成对应的解析类</span></span><br><span class="line">    IRuleConfigParser parser = parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">    String configText = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"json"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样 if 分支逻辑，依然耦合在业务逻辑中，<strong>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象</strong>。</p>
<h2 id="三、抽象工厂"><a href="#三、抽象工厂" class="headerlink" title="三、抽象工厂"></a>三、抽象工厂</h2><p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。<br>但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。针对规则配置的解析器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">针对规则配置的解析器：基于接口IRuleConfigParser</span><br><span class="line">JsonRuleConfigParser</span><br><span class="line">XmlRuleConfigParser</span><br><span class="line">YamlRuleConfigParser</span><br><span class="line">PropertiesRuleConfigParser</span><br><span class="line"></span><br><span class="line">针对系统配置的解析器：基于接口ISystemConfigParser</span><br><span class="line">JsonSystemConfigParser</span><br><span class="line">XmlSystemConfigParser</span><br><span class="line">YamlSystemConfigParser</span><br><span class="line">PropertiesSystemConfigParser</span><br></pre></td></tr></table></figure>
<p>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编写一个工厂类， 8 个工厂类。如果我们未来还需要增加针对业务配置的解析器接口（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。<br>过多的类也会让系统难维护，抽象工厂就是针对这种非常特殊的场景而诞生的，我们可以<strong>让一个工厂负责创建多个不同类型的对象</strong>（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">IRuleConfigParser <span class="title">createRuleParser</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">ISystemConfigParser <span class="title">createSystemParser</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//此处可以扩展新的parser类型，比如IBizConfigParser</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createRuleParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ISystemConfigParser <span class="title">createSystemParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createRuleParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ISystemConfigParser <span class="title">createSystemParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span></span><br></pre></td></tr></table></figure>
<h2 id="四、简单工厂模式VS工厂方法模式"><a href="#四、简单工厂模式VS工厂方法模式" class="headerlink" title="四、简单工厂模式VS工厂方法模式"></a>四、简单工厂模式VS工厂方法模式</h2><p>当创建逻辑比较复杂，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。</p>
<ul>
<li>当每个对象的创建逻辑都比较简单的时候，推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。</li>
<li>当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中</li>
<li>如果创建对象的逻辑并不复杂，那我们就直接通过 new 来创建对象就可以了，不需要使用工厂模式。</li>
</ul>
<p>总结来看，工厂模式，它的作用无外乎下面这四个。这也是判断要不要使用工厂模式的最本质的参考标准。</p>
<ul>
<li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li>
<li>代码复用：创建代码抽离到独立的工厂类之后可以复用。</li>
<li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li>
<li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li>
</ul>
<h2 id="五、精选评论"><a href="#五、精选评论" class="headerlink" title="五、精选评论"></a>五、精选评论</h2><p>1、静态工厂方法VS构造函数</p>
<ul>
<li>构造函数的名字无意义，方法的名字包含更多有用信息</li>
<li>构造函数只能返回当前Class类型对象，而方法可以返回当前类型对象、当前类型的子类对象</li>
<li>如果创建过程很复杂，那么方法可以把很多不应该由构造函数处理的过程放在方法中，让构造函数只处理初始化成员的工作，职责更单一。</li>
<li>方法可以控制生成对象的个数(单例，多例等)</li>
</ul>
<p>2、工厂方法的扩展性<br>工厂方法除了处理复杂对象创建这一职责，还有<strong>增加扩展点</strong>这优点。<br>工厂方法，在可能有扩展需求，比如要加对象池，缓存，或其他业务需求时，可以提供扩展的地方。所以，除非明确确定该类只会有简单数据载体的职责（值对象），不然建议还是用工厂方法好点。new这种操作是没有扩展性的。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>创建型</tag>
      </tags>
  </entry>
  <entry>
    <title>GeoHash编码</title>
    <url>/GeoHash%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h1 id="GeoHash编码"><a href="#GeoHash编码" class="headerlink" title="GeoHash编码"></a>GeoHash编码</h1><p>在处理地理位置信息时，直接去匹配两个哪怕距离很近的gps坐标，很可能都匹配不上。gps坐标的匹配，不应该做精确匹配，应该做范围匹配。</p>
<p>将地理位置进行编码，在检索时能够更快的进行地理空间上的检索，找到距离相近的位置。</p>
<a id="more"></a>
<h2 id="一、GeoHash原理"><a href="#一、GeoHash原理" class="headerlink" title="一、GeoHash原理"></a>一、GeoHash原理</h2><p>将二维的经纬度坐标点转换为一维的字符串，也就是编码，某一个字符串表示了某一个矩形区域，也就是说在这个矩形区域中的所有经纬度点都共享一套编码也就是字符串。</p>
<p>GeoHash算法，其实质其实是二分法。不断地将地球的经度、纬度范围，进行<strong>二分</strong>，输出1/0比特，<strong>偶数位放经度，奇数位放纬度</strong>，把2串编码组合生成新串形成一串二进制码（二分的次数越多，输出的bit串越长），然后将这一串二进制码，按照5bit一组进行<strong>base32编码</strong>，得到最终结果。</p>
<h2 id="二、GeoHash编码精度"><a href="#二、GeoHash编码精度" class="headerlink" title="二、GeoHash编码精度"></a>二、GeoHash编码精度</h2><table>
<thead>
<tr>
<th style="text-align:left"><strong>geohash长度</strong></th>
<th><strong>Lat位数</strong></th>
<th><strong>Lng位数</strong></th>
<th><strong>Lat误差</strong></th>
<th><strong>Lng误差</strong></th>
<th><strong>km误差</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td>2</td>
<td>3</td>
<td>±23</td>
<td>±23</td>
<td>±2500</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td>5</td>
<td>5</td>
<td>± 2.8</td>
<td>±5.6</td>
<td>±630</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td>7</td>
<td>8</td>
<td>± 0.70</td>
<td>± 0.7</td>
<td>±78</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td>10</td>
<td>10</td>
<td>± 0.087</td>
<td>± 0.18</td>
<td>±20</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td>12</td>
<td>13</td>
<td>± 0.022</td>
<td>± 0.022</td>
<td>±2.4</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td>15</td>
<td>15</td>
<td>± 0.0027</td>
<td>± 0.0055</td>
<td>±0.61</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td>17</td>
<td>18</td>
<td>±0.00068</td>
<td>±0.00068</td>
<td>±0.076</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td>20</td>
<td>20</td>
<td>±0.000086</td>
<td>±0.000172</td>
<td>±0.01911</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td>22</td>
<td>23</td>
<td>±0.000021</td>
<td>±0.000021</td>
<td>±0.00478</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td>25</td>
<td>25</td>
<td>±0.00000268</td>
<td>±0.00000536</td>
<td>±0.0005971</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td>27</td>
<td>28</td>
<td>±0.00000067</td>
<td>±0.00000067</td>
<td>±0.0001492</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td>30</td>
<td>30</td>
<td>±0.00000008</td>
<td>±0.00000017</td>
<td>±0.0000186</td>
</tr>
</tbody>
</table>
<h2 id="三、使用注意"><a href="#三、使用注意" class="headerlink" title="三、使用注意"></a>三、使用注意</h2><p>1、 由于GeoHash是将区域划分为一个个规则矩形，并对每个矩形进行编码，这样在查询附近POI信息时会导致以下问题，比如红色的点是我们的位置，绿色的两个点分别是附近的两个餐馆，但是在查询的时候会发现距离较远餐馆的GeoHash编码与我们一样（因为在同一个GeoHash区域块上），而较近餐馆的GeoHash编码与我们不一致。这个问题往往产生在边界处。</p>
<p><img src="/GeoHash编码/geohash.png" alt="geohash" style="zoom:150%;"></p>
<p>解决的思路很简单，我们查询时，除了使用定位点的GeoHash编码进行匹配外，还使用周围8个区域的GeoHash编码，这样可以避免这个问题。 </p>
<p>2、GeoHash算法使用的是Peano空间填充曲线，会产生突变，造成了编码虽然相似但距离可能相差很大，因此在查询附近点时候，首先筛选GeoHash编码相似的点，然后进行实际距离计算。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>大数定律与中心极限法则</title>
    <url>/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E6%B3%95%E5%88%99/</url>
    <content><![CDATA[<h1 id="大数定律与中心极限法则"><a href="#大数定律与中心极限法则" class="headerlink" title="大数定律与中心极限法则"></a>大数定律与中心极限法则</h1><p>大数定律，是概率论中讨论随机变量和的平均值的收敛情况，是数理统计学中参数估计的理论基础。中心极限定理，是概率论中讨论随机变量和的分布以正态分布为极限的一组定理，这组定理是数理统计学和误差分析的理论基础，指出了大量随机变量近似服从正态分布的条件。  </p>
<a id="more"></a>
<h2 id="一、大数定律"><a href="#一、大数定律" class="headerlink" title="一、大数定律"></a>一、大数定律</h2><p>设Y~1~, Y~2~，…,  Y~n~是一个随机变量序列，a是一个常数。若对于任意$\varepsilon &gt;0$，有<br>$$<br>\lim_{n \rightarrow \infty}P\left { \left | Y_{n}-a  \right |&lt;\varepsilon  \right }=1<br>$$<br>则称序列Y~1~, Y~2~，…,  Y~n~依概率收敛于a，记为<br>$$<br>Y_{n}\overset{P}{\rightarrow}a<br>$$</p>
<h3 id="1、弱大数定理（辛钦大数定理）"><a href="#1、弱大数定理（辛钦大数定理）" class="headerlink" title="1、弱大数定理（辛钦大数定理）"></a>1、弱大数定理（辛钦大数定理）</h3><p>设X~1~,   X~2~,  …,  X~n~是相互独立，服从统一分布的随机变量序列，且具有数学期望$E(X_{k})=\mu  (k=1,2,\cdots)$。则序列$\overline{X}=\frac{1}{n}\sum_{k=1}^{n}X_{k}$依概率收敛于$\mu$，即$\overline{X}\overset{P}{\rightarrow}\mu$。</p>
<h3 id="2、伯努利大数定理"><a href="#2、伯努利大数定理" class="headerlink" title="2、伯努利大数定理"></a>2、伯努利大数定理</h3><p>设$f_{A}$是n次独立重复试验中事件A发生的次数，p是事件A在每次试验中发生的概率，则对于任意正数$\varepsilon &gt;0$，有<br>$$<br>\lim_{n \to \infty}P\left {\left | \frac{f_{A}}{n}-p \right |&lt; \varepsilon \right }=1<br>$$</p>
<h2 id="二、中心极限定理"><a href="#二、中心极限定理" class="headerlink" title="二、中心极限定理"></a>二、中心极限定理</h2><h3 id="1、定理一（独立同分布的中心极限定理）"><a href="#1、定理一（独立同分布的中心极限定理）" class="headerlink" title="1、定理一（独立同分布的中心极限定理）"></a>1、定理一（独立同分布的中心极限定理）</h3><p>设随机变量X~1~,   X~2~,  …,  X~n~相互独立，服从同一分布，且具有数学期望和方差：$E(X_{k})=\mu ,D(X_{k})=\sigma ^{2}(k=1,2,3 \cdots)$，则随机变量之和$\sum_{n}^{k=1}X_{k}$的标准化变量<br>$$<br>Y_{n}=\frac{\sum_{k=1}^{n}X_{k}-E\left ( \sum_{k=1}^{n}X_{k}\right )}{\sqrt{D\left ( \sum_{k=1}^{n}X_{k}\right )}}=\frac{\sum_{k=1}^{n}X_{k}-n\mu }{\sqrt{n}\sigma }<br>$$<br>当n充分大时，<br>$$<br>\frac{\overline{X}-\mu }{\sigma /\sqrt{n}}\sim N(0,1)\<br>\overline{X}\sim N(\mu ,\sigma ^{2}/n)<br>$$</p>
<h3 id="2、定理三（迪莫夫-拉普拉斯定理）"><a href="#2、定理三（迪莫夫-拉普拉斯定理）" class="headerlink" title="2、定理三（迪莫夫-拉普拉斯定理）"></a>2、定理三（迪莫夫-拉普拉斯定理）</h3><p>设随机变量$\eta <em>{n}(n=1,2,3,\cdots )$服从参数为n, p(0&lt;p&lt;1)的二项分布，则对于任意x，有<br>$$<br>\lim</em>{n\rightarrow \infty}P\left { \frac{\eta <em>{n}-np}{\sqrt{np(1-p)}}\leqslant x \right }=\int</em>{-\infty}^{x}\frac{1}{\sqrt{2\pi }}e^{-t^{2}/2}dt=\Phi (x)<br>$$</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>双重检查</title>
    <url>/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<h1 id="双重检查-DCL"><a href="#双重检查-DCL" class="headerlink" title="双重检查(DCL)"></a>双重检查(DCL)</h1><p>双重检查锁定模式（也被称为”双重检查加锁优化”，”锁暗示”（Lock hint）) 是一种软件设计模式用来减少并发系统中竞争和同步的开销。双重检查锁定模式首先验证锁定条件(第一次检查)，只有通过锁定条件验证才真正的进行加锁逻辑并再次验证条件(第二次检查)。<br>它通常用于减少加锁开销，尤其是为多线程环境中的单例模式实现“惰性初始化”。<br><a id="more"></a></p>
<h2 id="一、错误的延时初始化"><a href="#一、错误的延时初始化" class="headerlink" title="一、错误的延时初始化"></a>一、错误的延时初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger instance;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Logger.class) &#123; <span class="comment">// 此处为类级别的锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Logger();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        writer.write(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述示例在单线程环境交易正常运行，但是在多线程环境就有可能会抛出异常。<br>问题在于创建对象并不是一个原子操作，创建一个对象实例，可分为以下三步</p>
<p>1、分配对象内存<br>2、调用构造器方法，执行初始化<br>3、将对象引用赋值给变量。</p>
<p>但在虚拟机实际运行时，以上指令可能发生重排序。虽然重排序并不影响单线程内的执行结果，但是在多线程的环境就带来一些问题。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>线程一</strong></th>
<th style="text-align:center"><strong>线程二</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">分配内存</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">变量赋值</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">判断对象是否为null</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">对象不为null，返回对象</td>
</tr>
<tr>
<td style="text-align:center">初始化对象</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>如上述流程线程二返回还未初始化的对象，进行访问时可能发生异常</p>
<h2 id="二、使用volatile变量"><a href="#二、使用volatile变量" class="headerlink" title="二、使用volatile变量"></a>二、使用volatile变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Logger instance;   <span class="comment">// java5 后volatile可防止指令重排序优化</span></span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Logger result = instance;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Logger.class) &#123; <span class="comment">// 此处为类级别的锁</span></span><br><span class="line">                result = instance;</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = result = <span class="keyword">new</span> Logger();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        writer.write(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>局部变量<code>result</code>可以避免在函数返回时对volatile变量的访问，volatile变量的访问需要访问主存，性能较差。。</p>
</blockquote>
<p>正确的双重检查锁定模式需要需要使用 <code>volatile</code>。<code>volatile</code>主要包含两个功能。</p>
<p>1、保证可见性。使用 <code>volatile</code> 定义的变量，将会保证对所有线程的可见性。</p>
<p>2、禁止指令重排序优化。</p>
<p>由于 <code>volatile</code> 禁止对象创建时指令之间重排序，所以其他线程不会访问到一个未初始化的对象，从而保证安全性。</p>
<blockquote>
<p><code>volatile</code>禁止指令重排序在 JDK 5 之后才被修复</p>
</blockquote>
<h2 id="三、使用final语义实现"><a href="#三、使用final语义实现" class="headerlink" title="三、使用final语义实现"></a>三、使用final语义实现</h2><p>final域的重排规则：<br>1、写final的重排规则：</p>
<ul>
<li>JMM禁止编译器把final域的写重排序到构造函数之外。</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。<br>写final域的重排序规则可以确保：<strong>在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了。</strong></li>
</ul>
<p>2、读final的重排规则：</p>
<ul>
<li>在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。<br>读final域的重排序规则可以确保：<strong>在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</strong></li>
</ul>
<p>3、如果final域是引用类型，那么增加如下约束：</p>
<ul>
<li>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> FinalWrapper&lt;Helper&gt; helperWrapper;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      FinalWrapper&lt;Helper&gt; wrapper = helperWrapper;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (helperWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  helperWrapper = <span class="keyword">new</span> FinalWrapper&lt;Helper&gt;(<span class="keyword">new</span> Helper());</span><br><span class="line">              &#125;</span><br><span class="line">              wrapper = helperWrapper;</span><br><span class="line">              <span class="comment">//在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了。</span></span><br><span class="line">              <span class="comment">//此处增加对helperWrapper的引用，可以确保FinalWrapper中的value已经成功初始化。</span></span><br><span class="line">              <span class="comment">//如果此处没有赋值给本地变量，final域的写操作保证不能生效，那么getHelper()方法并不能保证，被return的value已经被正确初始化过。</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> wrapper.value;</span><br><span class="line">      <span class="comment">//在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</span></span><br><span class="line">      <span class="comment">//所以此处的读取操作确保读value之前，会读取wrapper这个引用变量指向的对象，</span></span><br><span class="line">      <span class="comment">//而写操作又可以确保在对象可见之前，final域已经正确初始化了。所以此处肯定会读取到正确的value。</span></span><br><span class="line">      <span class="comment">//如果读final域不做这个保证，那么对value的读取操作有可能会被重排到对wrapper赋值之前，有可能读取到不正确的value值。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<a id="more"></a>
<h2 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h2><h3 id="1、处理资源访问冲突"><a href="#1、处理资源访问冲突" class="headerlink" title="1、处理资源访问冲突"></a>1、处理资源访问冲突</h3><p>比如，一个往文件中打印日志的 Logger 类，我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。</p>
<p>单例模式相对于类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。</p>
<h3 id="2、表示全局唯一类"><a href="#2、表示全局唯一类" class="headerlink" title="2、表示全局唯一类"></a>2、表示全局唯一类</h3><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如，配置信息类。</p>
<h2 id="二、单例模式的实现"><a href="#二、单例模式的实现" class="headerlink" title="二、单例模式的实现"></a>二、单例模式的实现</h2><ul>
<li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；</li>
<li>考虑对象创建时的线程安全问题；</li>
<li>考虑是否支持延迟加载；</li>
<li>考虑 getInstance() 性能是否高（是否加锁）。</li>
</ul>
<h3 id="1、饿汉模式"><a href="#1、饿汉模式" class="headerlink" title="1、饿汉模式"></a>1、饿汉模式</h3><p>饿汉式在类加载的时候，对instance 静态实例进行创建，instance 实例的创建过程是线程安全的，不支持延迟加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger instance = <span class="keyword">new</span> Logger();</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        writer.write(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、懒汉模式"><a href="#2、懒汉模式" class="headerlink" title="2、懒汉模式"></a>2、懒汉模式</h3><p>懒汉式支持延迟加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger instance;</span><br><span class="line">	<span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Logger <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Logger();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        writer.write(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getInstance() 这个方法加了一把锁（synchronzed），导致这个函数的并发度很低。</p>
<h3 id="3、双重检查"><a href="#3、双重检查" class="headerlink" title="3、双重检查"></a>3、双重检查</h3><p>既支持延迟加载、又支持高并发的单例实现方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Logger instance;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Logger.class) &#123; <span class="comment">// 此处为类级别的锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Logger();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        writer.write(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为在一些编译器上存在指令排序，所以instance变量需声明为volatile类型的，避免在多线程环境下是发生问题。</p>
<h3 id="4、静态内部类"><a href="#4、静态内部类" class="headerlink" title="4、静态内部类"></a>4、静态内部类</h3><p>这种实现方法既保证了线程安全，又能做到延迟加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger instance = <span class="keyword">new</span> Logger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        writer.write(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SingletonHolder 是一个静态内部类，当外部类加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。</p>
<h3 id="5、枚举"><a href="#5、枚举" class="headerlink" title="5、枚举"></a>5、枚举</h3><p>这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Logger &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line"></span><br><span class="line">    IdGenerator() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        writer.write(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>创建型</tag>
      </tags>
  </entry>
  <entry>
    <title>贝叶斯</title>
    <url>/%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
    <content><![CDATA[<h1 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h1><p>先验概率，后验概率，条件概率，贝叶斯，极大似然</p>
<a id="more"></a>
<h2 id="一、条件概率"><a href="#一、条件概率" class="headerlink" title="一、条件概率"></a>一、条件概率</h2><h3 id="1、条件概率"><a href="#1、条件概率" class="headerlink" title="1、条件概率"></a>1、条件概率</h3><p>条件概率涉及两个事件A与B，在事件B已发生的条件下，事件A再发生的概率为条件概率，记为P(A|B)。<br>设A与B是基本空间Ω中的两个事件，且P(B)&gt;0，在事件B已发生的条件下，事件A的条件概率P(A|B)定义为<br>$$<br>P(A | B)=\frac{P(A B)}{P(B)}<br>$$</p>
<h3 id="2、分割"><a href="#2、分割" class="headerlink" title="2、分割"></a>2、分割</h3><p>把基本空间Ω分为n个事件B~1~，B~2~，…，B~n~，假如<br>(1) $P\left(B_{i}\right)&gt;0, i=1,2, \cdots, n$<br>(2)B~1~，B~2~，…，B~n~互不相容<br>(3)$\bigcup_{i=1}^{n} B_{i}=\Omega$<br>则称时间组B~1~，B~2~，…，B~n~为基本空间Ω的一个分割。</p>
<h3 id="3、全概率公式"><a href="#3、全概率公式" class="headerlink" title="3、全概率公式"></a>3、全概率公式</h3><p>设B~1~，B~2~，…，B~n~是基本空间Ω的一个分割，则对Ω中任一事件A，有<br>$$<br>P(A)=\sum_{i=1}^{n} P\left(A | B_{i}\right) P\left(B_{i}\right)<br>$$</p>
<h3 id="4、贝叶斯公式"><a href="#4、贝叶斯公式" class="headerlink" title="4、贝叶斯公式"></a>4、贝叶斯公式</h3><p>设B~1~，B~2~，…，B~n~是基本空间Ω的一个分割，A是Ω中的一个事件，则在A给定的下，事件B~k~的条件概率为<br>$$<br>P\left(B_{k} | A\right)=\frac{P\left(A | B_{k}\right) P\left(B_{k}\right)}{\sum_{i=1}^{n} P\left(A | B_{i}\right) P\left(B_{i}\right)}, \quad k=1,2, \cdots, n<br>$$</p>
<h2 id="二、先验概率、后验概率与似然函数"><a href="#二、先验概率、后验概率与似然函数" class="headerlink" title="二、先验概率、后验概率与似然函数"></a>二、先验概率、后验概率与似然函数</h2><h3 id="1、先验概率"><a href="#1、先验概率" class="headerlink" title="1、先验概率"></a>1、先验概率</h3><p>先验概率是指根据以往经验和分析得到的概率，它往往作为“由因求果”问题中的“因”出现。</p>
<blockquote>
<ul>
<li>利用过去历史资料计算得到的先验概率，称为客观先验概率；</li>
<li>当历史资料无从取得或资料不完全时，凭人们的主观经验来判断而得到的先验概率，称为主观先验概率。</li>
</ul>
</blockquote>
<h3 id="2、后验概率"><a href="#2、后验概率" class="headerlink" title="2、后验概率"></a>2、后验概率</h3><p>在贝叶斯统计中，后验概率（Posterior probability）是在考虑和给出相关证据或数据后所得到的条件概率，表示在事情已经发生的条件下，该事发生原因是有某个因素引起的可能性的大小。</p>
<blockquote>
<p>一口袋里有3只红球、2只白球，采用不放回方式摸取，求：</p>
<p>⑴ 第一次摸到红球（记作A）的概率；</p>
<p>⑵ 第二次摸到红球（记作B）的概率；</p>
<p>⑶ 已知第二次摸到了红球，求第一次摸到的是红球的概率。</p>
<p>解：</p>
<p>(1) P(A) = 3/5     先验概率</p>
<p>(2) P(B) = P(A)P(B|A)+P(A’)P(B|A’) = 3/5*2/4+2/5*3/4=3/5</p>
<p>(3) P(A|B) =  P(A)P(B|A)/P(B)=1/2   后验概率</p>
</blockquote>
<h3 id="3、似然函数"><a href="#3、似然函数" class="headerlink" title="3、似然函数"></a>3、似然函数</h3><p>似然函数是一种关于统计模型中的参数的函数，表示模型参数中的似然性。</p>
<ul>
<li>概率，用于在已知一些参数的情况下，预测接下来在观测上所得到的结果</li>
<li>似然性，则是用于在已知某些观测所得到的结果时，对有关事物之性质的参数进行估值。</li>
</ul>
<p>已知有事件A发生，运用似然函数$ {L} (B\mid A) $，我们估计参数B的可能性。形式上，似然函数也是一种条件概率函数，但我们关注的变量改变了：<br>$$<br>b \mapsto P(A | B=b)<br>$$<br>一个似然函数乘以一个正的常数之后仍然是似然函数。对所有$ \alpha &gt;0 $，都可以有似然函数：<br>$$<br>L(b | A)=\alpha P(A | B=b)<br>$$</p>
<blockquote>
<p>假设硬币投出时会有$ p_{H}$的概率正面朝上，而有$ 1-p_{H}$的概率反面朝上。这时，通过观察已发生的两次投掷，条件概率可以改写成似然函数：<br>$$<br>L\left(p_{H} | \mathrm{HH}\right)=P\left(\mathrm{HH} | p_{H}=0.5\right)=0.25<br>$$<br>也就是说，对于取定的似然函数，在观测到两次投掷都是正面朝上时，$ p_{H}=0.5$的似然性是0.25。</p>
<p>如果考虑$ p_{H}=0.6$，那么似然函数的值也会改变，<br>$$<br>L\left(p_{H} | \mathrm{HH}\right)=P\left(\mathrm{HH} | p_{H}=0.6\right)=0.36<br>$$<br>这说明，如果参数$ p_{H}$的取值变成0.6的话，结果观测到连续两次正面朝上的概率要比假设$ p_{H}=0.5$时更大。也就是说，参数$ p_{H}$297取成0.6要比取成0.5更有说服力，更为“合理”。</p>
<p>1、在这个例子中，似然函数实际上等于：<br>$$<br>L(\theta | \mathrm{HH})=P\left(\mathrm{HH} | p_{H}=\theta\right)=\theta^{2}, 0 \leq p_{H} \leq 1<br>$$<br>如果取$ p_{H}=1$，那么似然函数达到最大值1。也就是说，当连续观测到两次正面朝上时，假设硬币投掷时正面朝上的概率为1是最合理的。</p>
<p>2、类似地，如果观测到的是三次投掷硬币，头两次正面朝上，第三次反面朝上，那么似然函数将会是：<br>$$<br>L(\theta | \mathrm{HHT})=P\left(\mathrm{HHT} | p_{H}=\theta\right)=\theta^{2}(1-\theta), \text {其中T表示反面朝上}, 0 \leq p_{H} \leq 1<br>$$<br>这时候，似然函数的最大值将会在$ p_{H}={\frac {2}{3}}$的时候取到。也就是说，当观测到三次投掷中前两次正面朝上而后一次反面朝上时，估计硬币投掷时正面朝上的概率$p_{H}={\frac {2}{3}}$是最合理的。</p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>动态数据源</title>
    <url>/%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
    <content><![CDATA[<h1 id="动态数据源"><a href="#动态数据源" class="headerlink" title="动态数据源"></a>动态数据源</h1><h2 id="一、AbstractRoutingDataSource"><a href="#一、AbstractRoutingDataSource" class="headerlink" title="一、AbstractRoutingDataSource"></a>一、AbstractRoutingDataSource</h2><p>AbstractRoutingDataSource类充当了<strong>DataSource的路由中介</strong>, 能有在<strong>运行时</strong>, 根据某种key值来<strong>动态切换</strong>到真正的DataSource上。</p>
<p><img src="/动态数据源/动态数据源.jpg" alt="动态数据源"></p>
<a id="more"></a>
<p>Spring对于多数据源，以数据库表为参照，大体上可以分成两大类情况：<br>1、表级上的跨数据库。即，对于不同的数据库却有相同的表（表名和表结构完全相同）。<br>2、非表级上的跨数据库。即，多个数据源不存在相同的表。 </p>
<p>通过实现抽象方法determineCurrentLookupKey返回预制数据源的key，以便在建立getConnection时选取指定的数据源，需要使用线程变量ThreadLocal进行保存</p>
<h2 id="二、工作流程"><a href="#二、工作流程" class="headerlink" title="二、工作流程"></a>二、工作流程</h2><p>1、初始化dataSource 映射Map</p>
<p>2、在Mybati拦截器中根据查询条件共同计算得出分库分表信息，并存于ThreadLocal环境变量</p>
<p>3、dataSource的determineCurrentLookupKey获取对应的ThreadLocal环境变量，进行目标DataSource的key值组装，以便在getConnection时可以在初始化的dataSource映射Map中找到对应的dataSource</p>
<h2 id="三、具体代码"><a href="#三、具体代码" class="headerlink" title="三、具体代码"></a>三、具体代码</h2><p>1、Spring配置DataSourceFactory工厂为datasource bean，工厂类中实例化RoutingDataSource、初始化targetDataSources和defaultTargetDataSource，并调用afterPropertiesSet进行解析写入resolvedDataSources和resolvedDefaultDataSource</p>
<p>2、配置SqlSessionFactoryBean工厂类为sqlSessionFactory，并注入dataSource、mapperLocations和plugins</p>
<p>3、plugins中增加Mybatis拦截器</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis自定义拦截器</title>
    <url>/Mybatis%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Mybatis自定义拦截器"><a href="#Mybatis自定义拦截器" class="headerlink" title="Mybatis自定义拦截器"></a>Mybatis自定义拦截器</h1><h2 id="一、Interceptor-接口"><a href="#一、Interceptor-接口" class="headerlink" title="一、Interceptor 接口"></a>一、Interceptor 接口</h2><p> Mybatis 为我们提供了一个 Interceptor 接口，通过实现该接口就可以定义我们自己的拦截器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.plugin;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="1、plugin-方法"><a href="#1、plugin-方法" class="headerlink" title="1、plugin 方法"></a>1、plugin 方法</h3><p>plugin 方法是拦截器用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理。当返回的是代理的时候我们可以对其中的方法进行拦截来调用 intercept 方法，当然也可以调用其他方法，</p>
<h3 id="2、-intercept-方法"><a href="#2、-intercept-方法" class="headerlink" title="2、 intercept 方法"></a>2、 intercept 方法</h3><p>intercept 方法就是要进行拦截的时候要执行的方法。</p>
<h3 id="3、setProperties-方法"><a href="#3、setProperties-方法" class="headerlink" title="3、setProperties 方法"></a>3、setProperties 方法</h3><p>setProperties 方法是用于在 Mybatis 配置文件中指定一些属性的。</p>
<h2 id="二、定义自己的拦截器"><a href="#二、定义自己的拦截器" class="headerlink" title="二、定义自己的拦截器"></a>二、定义自己的拦截器</h2><h3 id="1、plugin-方法和-intercept-方法："><a href="#1、plugin-方法和-intercept-方法：" class="headerlink" title="1、plugin 方法和 intercept 方法："></a>1、plugin 方法和 intercept 方法：</h3><p>定义自己的Interceptor最重要的是要实现 plugin 方法和 intercept 方法：</p>
<p> ① plugin 方法中决定是否要进行拦截进而决定要返回一个什么样的目标对象。</p>
<blockquote>
<p>对于 plugin 方法而言，其实 Mybatis 已经为我们提供了一个实现。Mybatis 中有一个叫做Plugin 的类，里面有一个静态方法 wrap(Object target,Interceptor interceptor)，通过该方法可以决定要返回的对象是目标对象还是对应的代理。</p>
</blockquote>
<p> ② intercept 方法就是要进行拦截的时候要执行的方法。</p>
<h3 id="2、-Intercepts和-Signature-注解"><a href="#2、-Intercepts和-Signature-注解" class="headerlink" title="2、@Intercepts和@Signature 注解"></a>2、@Intercepts和@Signature 注解</h3><p>对于实现自己的 Interceptor 而言有两个很重要的注解，一个是 @Intercepts，其值是一个@Signature 数组。</p>
<p>@Intercepts 用于表明当前的对象是一个 Interceptor，而 @Signature则表明要拦截的接口、方法以及对应的参数类型。@Signature 的参数：</p>
<ul>
<li><p>type：要拦截的接口</p>
</li>
<li><p>method：需要拦截的方法，存在于要拦截的接口之中</p>
</li>
<li><p>args：被拦截的方法所需要的参数</p>
</li>
</ul>
<blockquote>
<p>MyBatis 自定义拦截器，可以拦截的接口只有四种 :</p>
<ul>
<li>Executor.class，拦截执行器的方法</li>
<li>StatementHandler.class，拦截Sql语法构建的处理</li>
<li>ParameterHandler.class,  拦截参数的处理</li>
<li>ResultSetHandler.class, 拦截结果集的处理</li>
</ul>
</blockquote>
<h3 id="3、intercept-方法的参数-invocation"><a href="#3、intercept-方法的参数-invocation" class="headerlink" title="3、intercept 方法的参数 invocation"></a>3、intercept 方法的参数 invocation</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invocation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] args;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>target：<em>代理对象</em></p>
</li>
<li><p>method：<em>被监控方法对象</em></p>
</li>
<li><p>args：<em>当前被监控方法运行时需要的实参</em></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>CLion+STM32CubeMX+WSL进行STM32开发</title>
    <url>/CLion-STM32CubeMX-WSL%E8%BF%9B%E8%A1%8CSTM32%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>使用CLion和STM32CubeMX进行配置编辑</p>
<p>WSL进行编译与调试，无需安装MinGW</p>
<a id="more"></a>
<h1 id="Windows软件安装"><a href="#Windows软件安装" class="headerlink" title="Windows软件安装"></a>Windows软件安装</h1><h2 id="1、CLion"><a href="#1、CLion" class="headerlink" title="1、CLion"></a>1、<a href="https://www.jetbrains.com/clion/download/#section=windows" target="_blank" rel="noopener">CLion</a></h2><h2 id="2、STM32CubeMX"><a href="#2、STM32CubeMX" class="headerlink" title="2、STM32CubeMX"></a>2、<a href="https://www.st.com/zh/development-tools/stm32cubemx.html" target="_blank" rel="noopener">STM32CubeMX</a></h2><h2 id="3、openOCD"><a href="#3、openOCD" class="headerlink" title="3、openOCD"></a>3、<a href="http://openocd.org/" target="_blank" rel="noopener">openOCD</a></h2><h2 id="4、WSL-Ubuntu"><a href="#4、WSL-Ubuntu" class="headerlink" title="4、WSL-Ubuntu"></a>4、WSL-<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10" target="_blank" rel="noopener">Ubuntu</a></h2><h1 id="编译工具安装"><a href="#编译工具安装" class="headerlink" title="编译工具安装"></a>编译工具安装</h1><h2 id="1、arm-none-eabi-gcc安装"><a href="#1、arm-none-eabi-gcc安装" class="headerlink" title="1、arm-none-eabi-gcc安装"></a>1、<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads" target="_blank" rel="noopener">arm-none-eabi-gcc</a>安装</h2><p>下载x86_64-linux版本压缩包，解压在WSL自定义目录下（如/usr/lib/arm-gcc/）将解压目录重命名一下，方便后续调用</p>
<p><img src="/CLion-STM32CubeMX-WSL进行STM32开发/arm安装路径.png" alt="arm安装路径"></p>
<h2 id="2、配置WSL以方便CLion进行ssh连接"><a href="#2、配置WSL以方便CLion进行ssh连接" class="headerlink" title="2、配置WSL以方便CLion进行ssh连接"></a>2、配置WSL以方便CLion进行ssh连接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/JetBrains/clion-wsl/master/ubuntu_setup_env.sh &amp;&amp; bash ubuntu_setup_env.sh</span><br></pre></td></tr></table></figure>
<p>执行成功后会显示开启ssh的端口号</p>
<h2 id="3、配置CLion编译链"><a href="#3、配置CLion编译链" class="headerlink" title="3、配置CLion编译链"></a>3、配置CLion编译链</h2><p><img src="/CLion-STM32CubeMX-WSL进行STM32开发/编译链设置.png" alt="编译链设置"></p>
<p>连接设置</p>
<p><img src="/CLion-STM32CubeMX-WSL进行STM32开发/ssh配置.png" alt="ssh配置"></p>
<p>配置成功的话会自动发现WSL中已有编译链，其中Debugger需要设置成 /usr/lib/arm-gcc/gcc-arm-none-eabi/bin中的arm-none-eabi-gdb-py（C和C++编译器可以不管由后续CmakeList中指定）</p>
<blockquote>
<p>如果多次执行ubuntu_setup_env.sh脚本，ssh工具和CLion都无法进行ssh连接，可以尝试删除C:\Users\xxx\.ssh中的known_hosts文件后重新连接</p>
</blockquote>
<h2 id="4、开发工具配置"><a href="#4、开发工具配置" class="headerlink" title="4、开发工具配置"></a>4、开发工具配置</h2><p><img src="/CLion-STM32CubeMX-WSL进行STM32开发/开发工具.png" alt="开发工具"></p>
<h1 id="STM32CubeMX工程生成"><a href="#STM32CubeMX工程生成" class="headerlink" title="STM32CubeMX工程生成"></a>STM32CubeMX工程生成</h1><p>STM32CubeMX正常配置后，生成工程文件时Toolchain/IDE选择SW4STM32，即可生成工程文件夹</p>
<p><img src="/CLion-STM32CubeMX-WSL进行STM32开发/工程生成.png" alt="工程生成"></p>
<h1 id="CLion打开工程"><a href="#CLion打开工程" class="headerlink" title="CLion打开工程"></a>CLion打开工程</h1><h2 id="1、大小不敏感配置"><a href="#1、大小不敏感配置" class="headerlink" title="1、大小不敏感配置"></a>1、大小不敏感配置</h2><p><img src="/CLion-STM32CubeMX-WSL进行STM32开发/大小写参数.png" alt="大小写参数"></p>
<p>添加 idea.case.sensitive.fs=true 配置项</p>
<h2 id="2、CLion打开工程文件夹"><a href="#2、CLion打开工程文件夹" class="headerlink" title="2、CLion打开工程文件夹"></a>2、CLion打开工程文件夹</h2><p><img src="/CLion-STM32CubeMX-WSL进行STM32开发/工程打开.png" alt="工程打开"></p>
<h2 id="3、选择兼容开发板"><a href="#3、选择兼容开发板" class="headerlink" title="3、选择兼容开发板"></a>3、选择兼容开发板</h2><p>进入工程后会出现对话框，选择芯片相同的兼容开发板，开发板配置可以在配置的openOCD目录下（C:\OpenOCD\share\openocd\scripts\board）</p>
<p>如果没有显示或者选错，在下文可以重新设置</p>
<p><img src="/CLion-STM32CubeMX-WSL进行STM32开发/开发板选择.png" alt="开发板选择"></p>
<p>具体配置可以查询openOCD的配置</p>
<blockquote>
<p>我是使用STM32F407VGT6芯片、DAP的SWD方式进行下载调试</p>
<p>选择了相同芯片的stm32f4discovery.cfg</p>
<p>修改接口类型、传输模式等参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; # This is an STM32F4 discovery board with a single STM32F407VGT6 chip.</span><br><span class="line">&gt; # http://www.st.com/internet/evalboard/product/252419.jsp</span><br><span class="line">&gt; # 设置接口类型为cmsis-dap</span><br><span class="line">&gt; source [find interface/cmsis-dap.cfg]</span><br><span class="line">&gt; # 设置模式为SWD</span><br><span class="line">&gt; transport select swd</span><br><span class="line">&gt; # 设置芯片存储大小</span><br><span class="line">&gt; set WORKAREASIZE 0x10000000</span><br><span class="line">&gt; # 设置芯片类型</span><br><span class="line">&gt; source [find target/stm32f4x.cfg]</span><br><span class="line">&gt; # 注释掉复位方式-DAP-SWD需要</span><br><span class="line">&gt; #reset_config srst_only</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="4、修改CMakelist"><a href="#4、修改CMakelist" class="headerlink" title="4、修改CMakelist"></a>4、修改CMakelist</h2><p>此时工程会告警，找不到指定的编译器arm-none-eabi-gcc，需要修改工程的CMakeLists.txt</p>
<p><img src="/CLion-STM32CubeMX-WSL进行STM32开发/cmakelist告警.png" alt="cmakelist告警"></p>
<p>将CMakeLists.txt头部指定交叉编译器的变量，加上绝对路径，改完后Tools–Cmake–Reload Cmake Project，即可解决告警</p>
<p><img src="/CLion-STM32CubeMX-WSL进行STM32开发/编译变量修改.png" alt="编译变量修改"></p>
<h2 id="5、修改编译下载任务"><a href="#5、修改编译下载任务" class="headerlink" title="5、修改编译下载任务"></a>5、修改编译下载任务</h2><p>进去左上角任务设置，在Target、Executable下拉菜单中选中工程同名的elf文件</p>
<p>此处Board config file 点击 Assist 就可以重新选择兼容开发板信息</p>
<p><img src="/CLion-STM32CubeMX-WSL进行STM32开发/编译下载1.png" alt="编译下载1"></p>
<p><img src="/CLion-STM32CubeMX-WSL进行STM32开发/编译下载2.png" alt="编译下载2"></p>
<p>修改成功后，回到主页稍等几秒，任务设置图标上的红叉会消失，并且run和debug的按钮可点击</p>
<p><img src="/CLion-STM32CubeMX-WSL进行STM32开发/任务配置成功.png" alt="任务配置成功"></p>
<p>此时连接开发板，点击run或者debug即可进行烧写和debug</p>
<blockquote>
<p> Run信息始终为红色，不一定是烧写失败</p>
</blockquote>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>Haskell-函数的语法</title>
    <url>/Haskell-%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><p>模式匹配通过检查数据的特定结构来检查其是否匹配，并按模式从中取得数据。<br>在定义函数时，可以为不同的模式分别定义函数体，可以匹配一切数据类型—数字，字符，List，元组，等等。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sayMe :: (Integral a) =&gt; a -&gt; String   </span><br><span class="line">sayMe 1 = &quot;One!&quot;   </span><br><span class="line">sayMe 2 = &quot;Two!&quot;   </span><br><span class="line">sayMe 3 = &quot;Three!&quot;   </span><br><span class="line">sayMe 4 = &quot;Four!&quot;   </span><br><span class="line">sayMe 5 = &quot;Five!&quot;   </span><br><span class="line">sayMe x = &quot;Not between 1 and 5&quot;</span><br></pre></td></tr></table></figure>
<p>万能匹配：最后一个匹配可以匹配一切数值并将其绑定为x。<br>在定义模式时，一定要留一个万能匹配的模式，保证程序就不会因为不可预料的输入而崩溃。</p>
<h2 id="Tuple-匹配"><a href="#Tuple-匹配" class="headerlink" title="Tuple 匹配"></a>Tuple 匹配</h2><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">addVectors</span> :: (<span class="type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)   </span><br><span class="line"><span class="title">addVectors</span> (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)</span><br></pre></td></tr></table></figure>
<h2 id="List-匹配"><a href="#List-匹配" class="headerlink" title="List 匹配"></a>List 匹配</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tell :: (Show a) =&gt; [a] -&gt; String   </span><br><span class="line">tell [] = &quot;The list is empty&quot;   </span><br><span class="line">tell (x:[]) = &quot;The list has one element: &quot; ++ show x   </span><br><span class="line">tell (x:y:[]) = &quot;The list has two elements: &quot; ++ show x ++ &quot; and &quot; ++ show y   </span><br><span class="line">tell (x:y:_) = &quot;This list is long. The first two elements are: &quot; ++ show x ++ &quot; and &quot; ++ show y</span><br></pre></td></tr></table></figure>
<h2 id="as模式"><a href="#as模式" class="headerlink" title="as模式"></a>as模式</h2><p>将一个名字和@置于模式前，可以在按模式分割什么东西时仍保留对其整体的引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">capital :: String -&gt; String   </span><br><span class="line">capital &quot;&quot; = &quot;Empty string, whoops!&quot;   </span><br><span class="line">capital all@(x:xs) = &quot;The first letter of &quot; ++ all ++ &quot; is &quot; ++ [x]</span><br></pre></td></tr></table></figure>
<h1 id="门卫"><a href="#门卫" class="headerlink" title="门卫"></a>门卫</h1><p>门卫（guard）则用来检查一个值的某项属性是否为真。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bmiTell :: (RealFloat a) =&gt; a -&gt; String   </span><br><span class="line">bmiTell bmi   </span><br><span class="line">    | bmi &lt;= 18.5 = &quot;You&apos;re underweight, you emo, you!&quot;   </span><br><span class="line">    | bmi &lt;= 25.0 = &quot;You&apos;re supposedly normal. Pffft, I bet you&apos;re ugly!&quot;   </span><br><span class="line">    | bmi &lt;= 30.0 = &quot;You&apos;re fat! Lose some weight, fatty!&quot;   </span><br><span class="line">    | otherwise   = &quot;You&apos;re a whale, congratulations!&quot;</span><br></pre></td></tr></table></figure>
<h2 id="where关键字"><a href="#where关键字" class="headerlink" title="where关键字"></a>where关键字</h2><p>where关键字跟在门卫后面（最好是与竖线缩进一致），可以定义多个名字和函数，这些名字对每个门卫都是可见的，这一来就避免了重复。<br>函数在where绑定中定义的名字只对本函数可见，因此我们不必担心它会污染其他函数的命名空间。<br><strong>注意，其中的名字都是一列垂直排开，如果不这样规范，haskell就搞不清楚它们在哪个地方了。</strong><br>where绑定也可以使用模式匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">initials :: String -&gt; String -&gt; String   </span><br><span class="line">initials firstname lastname = [f] ++ &quot;. &quot; ++ [l] ++ &quot;.&quot;   </span><br><span class="line">    where (f:_) = firstname   </span><br><span class="line">          (l:_) = lastname</span><br></pre></td></tr></table></figure>
<p>where绑定可以定义名字，也可以定义函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a]  </span><br><span class="line">calcBmis xs = [bmi w h | (w, h) &lt;- xs]  </span><br><span class="line">    where bmi weight height = weight / height ^ 2</span><br></pre></td></tr></table></figure>
<h2 id="let-关键字"><a href="#let-关键字" class="headerlink" title="let 关键字"></a>let 关键字</h2><p>where绑定是在函数底部定义名字，对包括所有门卫在内的整个函数可见。<br>let绑定则是个表达式，允许你在任何位置定义局部变量，而对不同的门卫不可见，也可以使用模式匹配。<br>let的格式为let [bindings] in [expressions]。在let中绑定的名字仅对in部分可见。let里面定义的名字也得对齐到一列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cylinder :: (RealFloat a) =&gt; a -&gt; a -&gt; a   </span><br><span class="line">cylinder r h =  </span><br><span class="line">    let sideArea = 2 * pi * r * h   </span><br><span class="line">        topArea = pi * r ^2   </span><br><span class="line">    in  sideArea + 2 * topArea</span><br></pre></td></tr></table></figure>
<p>let绑定本身是个表达式，可以随处安放；而where绑定则是个语法结构。</p>
<p>let也可以定义局部函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[let square x = x * x in (square 5, square 3, square 2)]</span><br></pre></td></tr></table></figure>
<h1 id="case-表达式"><a href="#case-表达式" class="headerlink" title="case 表达式"></a>case 表达式</h1><p>模式匹配本质上不过就是case语句的语法糖而已。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head&apos; :: [a] -&gt; a   </span><br><span class="line">head&apos; xs = case xs of [] -&gt; error &quot;No head for empty lists!&quot;   </span><br><span class="line">                      (x:_) -&gt; x</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">describeList :: [a] -&gt; String   </span><br><span class="line">describeList xs = &quot;The list is &quot; ++ case xs of [] -&gt; &quot;empty.&quot;   </span><br><span class="line">                                               [x] -&gt; &quot;a singleton list.&quot;    </span><br><span class="line">                                               xs -&gt; &quot;a longer list.&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">describeList :: [a] -&gt; String   </span><br><span class="line">describeList xs = &quot;The list is &quot; ++ what xs   </span><br><span class="line">    where what [] = &quot;empty.&quot;   </span><br><span class="line">          what [x] = &quot;a singleton list.&quot;   </span><br><span class="line">          what xs = &quot;a longer list.&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Learn You a Haskell for Great Good!</category>
      </categories>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>chapter3-操作符</title>
    <url>/chapter3-%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h1><ol>
<li><p>对基本类型的赋值，是直接将一个变量的内容赋值给了另一个变量。</p>
</li>
<li><p>对对象“赋值”时，真正操作的是对对象的引用，两个变量均指向同一个对象。</p>
<a id="more"></a>
</li>
</ol>
<h1 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h1><p>加（+）减（-）乘（*）除（/）取模(%)</p>
<ol>
<li>整数除法会直接去掉结果的小数部分，而不是四舍五入。</li>
<li>操作符后紧跟一个等号可以同时进行运算和赋值操作，对于所有操作符都有效。</li>
<li>一元减号（-）用于转变数据的符号；</li>
<li>一元加号（+）只是为了与一元减号相对应，唯一的作用的是将较小类型的数提升为int <h1 id="自动递增和递减"><a href="#自动递增和递减" class="headerlink" title="自动递增和递减"></a>自动递增和递减</h1>递增操作符（++），递减操作符（–）</li>
<li>对于前缀操作符，会先执行递增或递减运算，再生成值</li>
<li>对于后缀操作符，会先生成值，再执行递增或递减运算</li>
</ol>
<h1 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h1><p>关系操作符生成的是一个boolean（布尔）结果，包括<br>小于（&lt;），大于（&gt;），小于等于（&lt;=），大于等于（&gt;=），等于（==），不等于（!=）</p>
<p>等于和不等于适用于所有的基本数据类型，其他比较符不适用于boolean类型</p>
<ol>
<li>当==和！=用于对象时，比较的就是对象的引用</li>
<li>如果需要比较两个对象的实际内容，则必须使用对象的equals()方法，该方法的默认行为是比较引用，需要根据实际类的情况进行重写，这个方法不适用于基本数据类型</li>
</ol>
<h1 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h1><p>与（&amp;&amp;）或（||）非（!）根据参数的逻辑关系，生成boolean结果</p>
<ol>
<li>与或非操作只可应用于布尔值，不能将非布尔值当做布尔值在逻辑表达式中使用</li>
<li>因为计算机无法精确表示浮点数，对浮点数进行比较需要小心</li>
<li>一旦能够明确确定整个逻辑表达式的值，就不会再计算表达式余下部分（短路现象）</li>
</ol>
<h1 id="直接常量"><a href="#直接常量" class="headerlink" title="直接常量"></a>直接常量</h1><table>
<thead>
<tr>
<th>后缀L</th>
<th>代表long类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>后缀F</td>
<td>代表float类型</td>
</tr>
<tr>
<td>后缀D</td>
<td>代表double类型</td>
</tr>
<tr>
<td>前缀0x</td>
<td>代表十六进制</td>
</tr>
</tbody>
</table>
<p>Integer和Long类的静态方法toBinaryString()可以将整数表示为二进制形式。<br>如果传入较小类型的整数，会自动转换成相应的类的类型</p>
<h1 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h1><p>按位操作符用来操作整数基本类型中的单个bit，即二进制位，对两个参数中对应的位执行布尔代数运算，并生成结果</p>
<p>与（&amp;）或（|）非（~）异或（^）</p>
<p>布尔类型可以作为一种单bit值计算，可以执行与、或、异或，但为了避免与逻辑NOT混淆，不能执行非（~）操作</p>
<p>按位操作不会发生短路现象<br>在移位表达式中，不能使用布尔运算</p>
<h1 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h1><table>
<thead>
<tr>
<th>左移操作符（&lt;&lt;）</th>
<th>按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0）</th>
</tr>
</thead>
<tbody>
<tr>
<td>“有符号”右移操作符（&gt;&gt;）</td>
<td>按照操作符右侧指定的位数将操作符左边的操作数向右移动（符号为正，则在高位补0；符号为正，则在高位补1）</td>
</tr>
<tr>
<td>“无符号”右移操作符（&gt;&gt;&gt;）</td>
<td>按照操作符右侧指定的位数将操作符左边的操作数向右移动（高位补0）</td>
</tr>
</tbody>
</table>
<ol>
<li>如果对char、byte或者short类型的数值进行移位处理，则在移位之前转换为int类型，并且得到的结果也是一个int类型的值。</li>
<li>如果对long类型进行处理，最后得到的结果也是long</li>
</ol>
<h1 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h1><p>boolean-exp ? value0 : value1<br>如果boolean-exp（布尔表达式）的结果为true，就计算value0并返回；如果boolean-exp（布尔表达式）的结果为false，就计算value1并返回.</p>
<h1 id="字符串操作-和"><a href="#字符串操作-和" class="headerlink" title="字符串操作+和+="></a>字符串操作+和+=</h1><p>连接字符串<br>如果表达式以一个字符串起头，那么后续的所有操作数都必须是字符串类型</p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ol>
<li>窄化转换，将较大数据类型转换成较小数据类型，面临信息丢失，需要显式进行类型转换。将float和double转型成整型时，总是对数字进行截尾。</li>
<li>扩展转换，不必显式进行类型转换。</li>
<li>只要类型比int小（char、byte、short）这些值会转换成int，生成的结果也是int</li>
<li>通常表达式中出现的最大的数据类型决定了表达式最终结果的数据类型。</li>
</ol>
]]></content>
      <categories>
        <category>ThinkinginJava</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Haskell-类型和类型类</title>
    <url>/Haskell-%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><table>
<thead>
<tr>
<th>Int</th>
<th>表示整数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Integer</td>
<td>表示无界整数</td>
</tr>
<tr>
<td>Float</td>
<td>表示单精度的浮点数</td>
</tr>
<tr>
<td>Double</td>
<td>表示双精度的浮点数</td>
</tr>
<tr>
<td>Bool</td>
<td>表示布尔值，它只有两种值：True和False</td>
</tr>
<tr>
<td>Char</td>
<td>表示一个字符</td>
</tr>
<tr>
<td>String</td>
<td>表示字符串，一组字符的List即为字符串，和[Char]一样</td>
</tr>
</tbody>
</table>
<ol>
<li><p><strong>:t</strong>命令处理一个表达式的输出结果为表达式后跟::及其类型，::读作“它的类型为”。</p>
</li>
<li><p>函数的类型声明：函数名::类型-&gt;类型-&gt;类型<br> 参数之间由-&gt;分隔，而与返回值之间并无特殊差异，返回值是最后一项。</p>
 <a id="more"></a>
</li>
</ol>
<h1 id="类型变量"><a href="#类型变量" class="headerlink" title="类型变量"></a>类型变量</h1><p>类型变量可以是任意的类型，与其他语言中的泛型(generic)很相似，但在haskell中要更为强大。它可以让我们轻而易举地写出类型无关的函数，使用到类型变量的函数被称作“多态函数 ”。</p>
<h1 id="类型类"><a href="#类型类" class="headerlink" title="类型类"></a>类型类</h1><p>类型定义行为的接口，如果一个类型属于某类型类，那它必实现了该类型类所描述的行为，可以把它看做是java中接口（interface）的类似物。</p>
]]></content>
      <categories>
        <category>Learn You a Haskell for Great Good!</category>
      </categories>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>Haskell-入门</title>
    <url>/Haskell-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="简单运算"><a href="#简单运算" class="headerlink" title="简单运算"></a>简单运算</h1><ol>
<li>一行可以使用多个运算符，按照运算符优先等级机选，可以使用括号改变优先次序。</li>
<li>使用负数时最好将其置于括号中。</li>
<li><strong>&amp;&amp;</strong> 逻辑与，<strong>||</strong> 逻辑或，<strong>not</strong> 逻辑否，<strong>==</strong> 相等判断，<strong>/=</strong> 不等判断。</li>
<li>函数调用拥有最高的优先级。</li>
<li>如果某函数有两个参数，也可以用 <strong>`</strong> 符号将它括起，以中缀函数的形式调用它。div 92 10等价于92 `div` 10。</li>
<li>使用<strong>let</strong>关键字定义常量。<a id="more"></a>
</li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol>
<li>函数的声明形式：先函数名，后跟由空格分隔的参数表。但在声明中一定要在 = 后面定义函数的行为。</li>
<li>if语句，haskell中if语句的else部分是不可省略。if(condition) then  else</li>
</ol>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><ol>
<li>List是一种单类型的数据结构，可以用来存储多个类型相同的元素。一个List由方括号括起，其中的元素用逗号分隔开来。</li>
<li>使用<strong>++</strong>运算符可以将两个List合并。Haskell会遍历整个的List(++符号左边的那个)。当左侧List长度很长时，执行效率较低。</li>
<li><strong>:</strong> 运算符可以连接一个元素到一个List或者字符串之中，而++运算符则是连接两个List。若要使用++运算符连接单个元素到一个List之中，就用方括号把它括起使之成为单个元素的List。</li>
<li>使用 <strong>!!</strong> 运算符可以按照索引取得List中的元素，索引的下标从0开始。</li>
<li><p>List同样也可以用来装List，甚至是List的List的List。List中的List可以是不同长度，但必须得是相同的类型。</p>
<h1 id="List常用函数"><a href="#List常用函数" class="headerlink" title="List常用函数"></a>List常用函数</h1></li>
</ol>
<table>
<thead>
<tr>
<th>head</th>
<th>返回List的首个元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>tail</td>
<td>返回List除去头部之后的部分</td>
</tr>
<tr>
<td>last</td>
<td>返回LIst的最后一个元素</td>
</tr>
<tr>
<td>init</td>
<td>返回LIst除去最后一个元素的部分</td>
</tr>
<tr>
<td>length</td>
<td>返回List的长度</td>
</tr>
<tr>
<td>null</td>
<td>检查List是否为空</td>
</tr>
<tr>
<td>reverse</td>
<td>将List反转</td>
</tr>
<tr>
<td>take</td>
<td>返回List的前几个元素</td>
</tr>
<tr>
<td>drop</td>
<td>删除List中的前几个元素</td>
</tr>
<tr>
<td>maximum</td>
<td>返回List中最大的那个元素</td>
</tr>
<tr>
<td>minimum</td>
<td>返回List中最小的那个元素</td>
</tr>
<tr>
<td>sum</td>
<td>返回List中所有元素的和</td>
</tr>
<tr>
<td>product</td>
<td>返回List中所有元素的积</td>
</tr>
<tr>
<td>elem</td>
<td>判断一个元素是否在包含于List，通常以中缀函数的形式调用它</td>
</tr>
</tbody>
</table>
<h1 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h1><ol>
<li>[start..end]构造连续List。</li>
<li>[start,start+d..end]构造步长为d的List.</li>
<li>cycle接受一个List做参数并返回一个无限List。</li>
<li>repeat接受一个值作参数，并返回一个仅包含该值的无限List。</li>
<li>replicate可以得到相同元素的List，如replicate 3 10，得[10,10,10]。</li>
</ol>
<h1 id="List-Comprehension"><a href="#List-Comprehension" class="headerlink" title="List Comprehension"></a>List Comprehension</h1><p> List Comprehension可以从既有的List中按照规则产生一个新List。</p>
<ol>
<li>从多个List中取元素时<br>[ x | x &lt;- [10..20], x /= 13, x /= 15, x /= 19]   </li>
<li>从多个List中取元素时，comprehension会把所有的元素组合交付给输出函数。<br>[ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]   </li>
<li>操作含有List的List，使用嵌套的List comprehension<br>[ [ x | x &lt;- xs, even x ] | xs &lt;- xxs]   </li>
<li>List Comprehension可以分成多行</li>
</ol>
<h1 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h1><p>Tuple中的项不必为同一类型，在Tuple里可以存入多类型项的组合。<br>Tuple的类型取决于其中项的数目与其各自的类型。<br>Tuple中的项 由括号括起，并由逗号隔开。</p>
<h2 id="序对"><a href="#序对" class="headerlink" title="序对"></a>序对</h2><p>一个长度为2的Tuple，也可以称作序对，Pair。</p>
<ol>
<li>fst返回一个序对的首项。</li>
<li>snd返回序对的尾项。</li>
<li>这两个函数仅对序对有效，而不能应用于三元组，四元组和五元组之上。</li>
<li>zip可以用来生成一组序对(Pair)的List。它取两个List，然后将它们交叉配对，形成一组序对的List。较长的那个会在中间断开，去匹配较短的那个。</li>
</ol>
]]></content>
      <categories>
        <category>Learn You a Haskell for Great Good!</category>
      </categories>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>chapter2-一切都是对象</title>
    <url>/chapter2-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="对象储存"><a href="#对象储存" class="headerlink" title="对象储存"></a>对象储存</h1><ol>
<li><p><strong>寄存器</strong>。最快的存储区，位于处理器的内部。不能直接控制，C和C++允许向编译器建议寄存器的分配方式。</p>
</li>
<li><p><strong>堆栈</strong>。位于通用RAM（随机访问存储器）中，通过堆栈指针可以从处理器获得直接支持。堆栈指针向下移动，则分配新内存；向上移动，则释放那些内存。这是一种快速有效的分配存储方式，仅次于寄存器。Java必须知道存储在堆栈内所有项目的生命周期，以便于移动堆栈指针。Java对象并不存储于其中，某些Java数据存储于堆栈中—特别是对象的引用。</p>
</li>
<li><p><strong>堆</strong>。一种通用内存池（也位于RAM区），用于存放所有Java对象。编译器不需要知道存储的数据在堆里存活多长时间。用堆进行存储分配和清理可能比用堆栈进行存储分配需要更多时间。</p>
</li>
<li><p><strong>常量存储</strong>。常量通常直接存放在程序代码内部。</p>
</li>
<li><p><strong>非RAM存储</strong>。</p>
<a id="more"></a>
</li>
</ol>
<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><table>
<thead>
<tr>
<th>基本类型</th>
<th>大小</th>
<th>最小值</th>
<th>最大值</th>
<th>包装器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>—</td>
<td>—</td>
<td>—</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>16-bit</td>
<td>Unicode 0</td>
<td>Unicode 2<sup>16</sup>-1</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>8-bit</td>
<td>-128</td>
<td>127</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>16-bit</td>
<td>-2<sup>15</sup></td>
<td>2<sup>15</sup>-1</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>32-bit</td>
<td>-2<sup>31</sup></td>
<td>2<sup>31</sup>-1</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>64-bit</td>
<td>-2<sup>63</sup></td>
<td>2<sup>63</sup>-1</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>32-bit</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>64-bit</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td>Double</td>
</tr>
<tr>
<td>void</td>
<td>—</td>
<td>—</td>
<td>—</td>
<td>Void</td>
</tr>
</tbody>
</table>
<p><strong>所有数值类型都有正负号，所以不要寻找无符号的数值类型。</strong></p>
<h1 id="高精度数字"><a href="#高精度数字" class="headerlink" title="高精度数字"></a>高精度数字</h1><ol>
<li><strong>BigInteger</strong>。支持任意精度的整数。</li>
<li><p><strong>BigDecimal</strong>。支持任意精度的定点数。</p>
<p><strong>这两个类提供的操作与对基本类型所能执行的操作相似，但是必须以方法调用的方式取代运算符来实现。</strong></p>
</li>
</ol>
<h1 id="成员变量默认值"><a href="#成员变量默认值" class="headerlink" title="成员变量默认值"></a>成员变量默认值</h1><table>
<thead>
<tr>
<th>基本类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’(null)</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
</tbody>
</table>
<p><strong>当变量作为类的成员变量使用时，Java才确保给定相应的默认值，并不适用于“局部”变量。</strong></p>
<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><p>当声明一个事物是static时，就说明这个域或方法不会与包含它的那个类的任何对象实例关联在一起。<br>static字段对于每个类来说都只有一份储存空间。</p>
<h1 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h1><ul>
<li>类名首字母大写；如果类名由多个单词构成，那么把它们连在一起，其中每个单词的首字母大写。</li>
<li>方法、字段以及对象的引用名称等的命名，与类的风格一致，只是标识符的第一个字母采用小写。</li>
</ul>
]]></content>
      <categories>
        <category>ThinkinginJava</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
