---
title: Java中的偏向锁、轻量级锁、重量级锁
date: 2021-04-07 00:10:28
categories:
- java
tags:
---

# Java中的偏向锁、轻量级锁、重量级锁

<!-- more -->

## 一、Java 对象头

每一个 Java 对象都至少占用 2 个字宽的内存(数组类型占用3个字宽)。

- 第一个字宽也被称为对象头**Mark Word**。 对象头包含了多种不同的信息， 其中就包含对象锁相关的信息。
- 第二个字宽是指向定义该对象类信息（class metadata）的指针

![java对象头](/Java中的偏向锁、轻量级锁、重量级锁/java对象头.png)

## 二、无锁 -> 偏向锁

1. 首先读取目标对象的 MarkWord, 判断是否处于可偏向的状态

2. 如果为可偏向状态, 则尝试用 CAS 操作， 将自己的线程 ID 写入MarkWord

   - 如果 CAS 操作成功， 则认为已经获取到该对象的偏向锁， 执行同步块代码 。补充： 一个线程在执行完同步代码块以后， 并不会尝试将 MarkWord 中的 thread ID 赋回原值 。这样做的好处是： 如果该线程需要再次对这个对象加锁，而这个对象之前一直没有被其他线程尝试获取过锁，依旧停留在可偏向的状态下， 即可在不修改对象头的情况下， 直接认为偏向成功。

   - 如果 CAS 操作失败， 则说明， 有另外一个线程 Thread B 抢先获取了偏向锁。 这种状态说明该对象的竞争比较激烈， 此时需要撤销 Thread B 获得的偏向锁，将 Thread B 持有的锁升级为轻量级锁。 该操作需要等待全局安全点 JVM safepoint ( 此时间点， 没有线程在执行字节码) 。

3. 如果是**已偏向状态**， 则检测 MarkWord 中存储的 thread ID 是否等于当前 thread ID 。

   - 如果相等， 则证明本线程已经获取到偏向锁， 可以直接继续执行同步代码块
   - 如果不等， 则证明该对象目前偏向于其他线程， 需要**撤销**偏向锁

## 三、偏向锁的撤销

 偏向锁的撤销（Revoke） 操作并不是将对象恢复到无锁可偏向的状态， 而是在偏向锁的获取过程中， 发现了竞争时， 直接将一个被偏向的对象“升级到” 被加了轻量级锁的状态。 

偏向锁的 **撤销（revoke）** 是一个很特殊的操作， 为了执行撤销操作， 需要等待**全局安全点（Safe Point）**， 此时间点所有的工作线程都停止了**字节码**的执行。

在偏向锁 CAS 更新操作失败以后， 等待到达全局安全点。
通过 MarkWord 中已经存在的 Thread Id 找到成功获取了偏向锁的那个线程, 然后在该线程的栈帧中补充上轻量级加锁时，会保存的锁记录（Lock Record），然后将被获取了偏向锁对象的 MarkWord 更新为指向这条锁记录的指针。
至此， 锁撤销操作完成， 阻塞在安全点的线程可以继续执行。

## 四、偏向锁的批量再偏向

偏向锁并没有直观意义上的“释放锁”操作， 提供了批量再偏向机制（Bulk Rebias）机制

1. 首先引入一个概念epoch，其本质是一个时间戳，代表了偏向锁的有效性，epoch存储在可偏向对象的MarkWord中。除了对象中的epoch,对象所属的类class信息中，也会保存一个epoch值。
2. 每当遇到一个全局安全点时，比如要对class C 进行批量再偏向，则首先对 class C中保存的epoch进行增加操作，得到一个新的epoch_new
3. 然后扫描所有持有 class C 实例的线程栈，根据线程栈的信息判断出该线程是否锁定了该对象，仅将epoch_new的值赋给被锁定的对象中，也就是现在偏向锁还在被使用的对象才会被赋值epoch_new。
4. 退出安全点后，当有线程需要尝试获取偏向锁时，直接检查 class C 中存储的 epoch 值是否与目标对象中存储的 epoch 值相等， 如果不相等，则说明该对象的偏向锁已经无效了（因为（3）步骤里面已经说了只有偏向锁还在被使用的对象才会有epoch_new，这里不相等的原因是class C里面的epoch值是epoch_new,而当前对象的epoch里面的值还是epoch），此时竞争线程可以尝试对此对象重新进行偏向操作。

## 五、偏向锁 -> 轻量级锁

存在超过一个线程竞争某一个对象时， 会发生偏向锁的撤销操作。 偏向锁撤销后， 对象可能处于两种状态：

- 一种是**不可偏向的无锁状态**（原来已经获取了偏向锁的线程已经执行完了同步代码块）

- 另一种是**不可偏向的已锁 ( 轻量级锁) 状态**（原来已经获取了偏向锁的线程也可能尚未执行完同步代码块）


轻量级加锁

1. 在线程执行同步代码块之前，JVM会现在当前线程的栈桢中创建用于存储锁记录的空间，并将锁对象头中的 markWord 信息复制到锁记录中，这个官方称为 Displaced Mard Word。然后线程尝试使用 CAS 将对象头中的 MarkWord 替换为指向锁记录的指针。如果替换成功，则进入步骤2，失败则进入步骤3。
2. CAS 替换成功说明当前线程已获得该锁，此时在栈桢中锁标志位信息也更新为轻量级锁状态：00。此时的栈桢与锁对象头的状态如图二所示。
3. 如果CAS 替换失败则说明当前时间锁对象已被某个线程占有，那么此时当前线程只有通过自旋的方式去获取锁。如果在自旋一定次数后仍为获得锁，那么轻量级锁将会升级成重量级锁。

## 六、重量级锁

重量级锁依赖于操作系统的互斥量（mutex） 实现，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。