---
title: Redis性能
date: 2021-04-07 00:09:43
categories:
- Redis
tags:
- Redis
---

# Redis性能

<!-- more -->

## 一、Redis 内部的阻塞式操作

Redis 的网络 IO 和键值对读写是由主线程完成的。那么，如果在主线程上执行的操作消耗的时间太长，就会引起主线程阻塞。

### 1.1 和客户端交互时的阻塞点

1. **集合全量查询和聚合操作**。Redis 中涉及集合的操作复杂度通常为 O(N)，复杂度高的增删改查操作肯定会阻塞 Redis。
2. **bigkey 删除操作**。删除操作的本质是要释放键值对占用的内存空间，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。
3. **清空数据库**。

### 1.2 和磁盘交互时的阻塞点

**AOF 日志同步写**。Redis 采用子进程的方式生成 RDB 快照文件，以及执行 AOF 日志重写操作。这样一来，这两个操作由子进程负责执行，慢速的磁盘 IO 就不会阻塞主线程了。但如果AOF使用同步写回策略。就会阻塞主线程了。

### 1.3 主从节点交互时的阻塞点

**加载 RDB 文件**。在主从集群中，主库需要生成 RDB 文件，并传输给从库。主库在复制的过程中，创建和传输 RDB 文件都是由子进程来完成的，不会阻塞主线程。但从库接收到RDB 文件后，需要**清空当前数据库**，还需要**把 RDB 文件加载到内存**。

## 二、CPU 核和 NUMA 架构的影响

### 2.1 常见CPU 结构

![cpu常见结构](/Redis性能/cpu常见结构.jpg)

一个 CPU 处理器中一般有多个运行核心，我们把一个运行核心称为一个物理核，每个物理核都可以运行应用程序，每个物理核通常都会运行两个超线程，也叫作逻辑核。每个物理核都拥有私有的一级缓存（Level 1 cache，简称 L1 cache），包括一级指令缓存和一级数据缓存，以及私有的二级缓存（Level 2 cache，简称 L2 cache）。不同的物理核还会共享一个共同的三级缓存（Level 3 cache，简称为 L3 cache）。

服务器上通常还会有多个 CPU 处理器（也称为多 CPU Socket），每个处理器有自己的物理核（包括 L1、L2 缓存），L3 缓存，以及连接的内存，同时，不同处理器间通过总线连接。

- L1、L2 缓存中的指令和数据的访问速度很快，所以，充分利用 L1、L2 缓存，可以有效缩短应用程序的执行时间；
- 在 NUMA 架构下，如果应用程序从一个 Socket 上调度到另一个 Socket 上，就可能会出现远端内存访问的情况，这会直接增加应用程序的执行时间。

### 2.2 CPU 多核对 Redis 性能的影响

如果在 CPU 多核场景下，Redis 实例被频繁调度到不同 CPU 核上运行的话，对 Redis 实例的请求处理时间影响较大了。每调度一次，一些请求就会受到运行时信息、指令和数据重新加载过程的影响，这就会导致某些请求的延迟明显高于其他请求。

要避免 Redis 总是在不同 CPU 核上来回调度执行，我们可以把 Redis 实例和 CPU 核绑定了，让一个 Redis 实例固定运行在一个 CPU 核上。我们可以使用 taskset 命令把一个程序绑定在一个核上运行。

**在 CPU 多核的环境下，通过绑定 Redis 实例和 CPU 核，可以有效提高 Redis 的性能。**

### 2.3 NUMA 架构对 Redis 性能的影响

在 CPU 的 NUMA 架构下，当网络中断处理程序、Redis 实例分别和 CPU 核绑定后，就会有一个潜在的风险：**如果网络中断处理程序和 Redis 实例各自所绑的 CPU 核不在同一个 CPU Socket 上，那么，Redis 实例读取网络数据时，就需要跨 CPU Socket 访问内存，这个过程会花费较多时间**。

**为了避免 Redis 跨 CPU Socket 访问网络数据，我们最好把网络中断程序和 Redis 实例绑在同一个 CPU Socket 上。**

### 2.4 绑核的风险和解决方案

当我们把 Redis 实例绑到一个 CPU 逻辑核上时，就会导致子进程、后台线程和 Redis 主线程竞争 CPU 资源，一旦子进程或后台线程占用 CPU 时，主线程就会被阻塞，导致 Redis 请求延迟增加。

1. **一个 Redis 实例对应绑一个物理核**。可以在一定程度上缓解 CPU 资源竞争，但它们相互之间的 CPU 竞争仍然还会存在。
2. **优化 Redis 源码，把子进程和后台线程绑到不同的 CPU 核上**。

## 三、Redis 内存碎片

Redis 是内存数据库，内存利用率的高低直接关系到 Redis 运行效率的高低。为了让用户能监控到实时的内存使用情况，Redis 自身提供了 INFO 命令，可以用来查询内存使用的详细信息

```shell
INFO memory
# Memory
used_memory:1073741736
used_memory_human:1024.00M
used_memory_rss:1997159792
used_memory_rss_human:1.86G
…
mem_fragmentation_ratio:1.86
```

- used_memory_rss 是操作系统实际分配给 Redis 的物理内存空间，里面就包含了碎片；

- used_memory 是 Redis 为了保存数据实际申请使用的空间。
- mem_fragmentation_ratio是used_memory_rss 和 used_memory 相除的结果，表示的就是 Redis 当前的内存碎片率