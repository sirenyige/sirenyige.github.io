---
title: 双重检查
date: 2020-05-17 18:23:58
categories:
tags:
---

# 双重检查(DCL)

双重检查锁定模式（也被称为"双重检查加锁优化"，"锁暗示"（Lock hint）) 是一种软件设计模式用来减少并发系统中竞争和同步的开销。双重检查锁定模式首先验证锁定条件(第一次检查)，只有通过锁定条件验证才真正的进行加锁逻辑并再次验证条件(第二次检查)。
它通常用于减少加锁开销，尤其是为多线程环境中的单例模式实现“惰性初始化”。
<!-- more -->
## 一、错误的延时初始化
```java
public class Logger {
    private static Logger instance;
    private FileWriter writer;
    private Logger() { }
    public static Logger getInstance() {
        if (instance == null) {
            synchronized (Logger.class) { // 此处为类级别的锁
                if (instance == null) {
                    instance = new Logger();
                }
            }
        }
        return instance;
    }
    public void log(String message) {
        writer.write(message);
    }
}
```
上述示例在单线程环境交易正常运行，但是在多线程环境就有可能会抛出异常。
问题在于创建对象并不是一个原子操作，创建一个对象实例，可分为以下三步

1、分配对象内存
2、调用构造器方法，执行初始化
3、将对象引用赋值给变量。

但在虚拟机实际运行时，以上指令可能发生重排序。虽然重排序并不影响单线程内的执行结果，但是在多线程的环境就带来一些问题。

| **线程一** |       **线程二**       |
| :--------: | :--------------------: |
|  分配内存  |           -            |
|  变量赋值  |           -            |
|     -      |   判断对象是否为null   |
|     -      | 对象不为null，返回对象 |
| 初始化对象 |           -            |

如上述流程线程二返回还未初始化的对象，进行访问时可能发生异常

## 二、使用volatile变量

```java
public class Logger {
    private volatile static Logger instance;   // java5 后volatile可防止指令重排序优化
    private FileWriter writer;
    private Logger() { }
    public static Logger getInstance() {
        Logger result = instance;
        if (result == null) {
            synchronized (Logger.class) { // 此处为类级别的锁
                result = instance;
                if (result == null) {
                    instance = result = new Logger();
                }
            }
        }
        return result;
    }
    public void log(String message) {
        writer.write(message);
    }
}
```

> 局部变量`result`可以避免在函数返回时对volatile变量的访问，volatile变量的访问需要访问主存，性能较差。。

正确的双重检查锁定模式需要需要使用 `volatile`。`volatile`主要包含两个功能。

1、保证可见性。使用 `volatile` 定义的变量，将会保证对所有线程的可见性。

2、禁止指令重排序优化。

由于 `volatile` 禁止对象创建时指令之间重排序，所以其他线程不会访问到一个未初始化的对象，从而保证安全性。

> `volatile`禁止指令重排序在 JDK 5 之后才被修复

## 三、使用final语义实现

final域的重排规则：
1、写final的重排规则：
- JMM禁止编译器把final域的写重排序到构造函数之外。
- 编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。
写final域的重排序规则可以确保：**在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了。**

2、读final的重排规则：

- 在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。
读final域的重排序规则可以确保：**在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。**

3、如果final域是引用类型，那么增加如下约束：

- 在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。


```java
 public class Foo {
   private FinalWrapper<Helper> helperWrapper;

   public Helper getHelper() {
      FinalWrapper<Helper> wrapper = helperWrapper;

      if (wrapper == null) {
          synchronized(this) {
              if (helperWrapper == null) {
                  helperWrapper = new FinalWrapper<Helper>(new Helper());
              }
              wrapper = helperWrapper;
              //在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了。
              //此处增加对helperWrapper的引用，可以确保FinalWrapper中的value已经成功初始化。
              //如果此处没有赋值给本地变量，final域的写操作保证不能生效，那么getHelper()方法并不能保证，被return的value已经被正确初始化过。
          }
      }
      return wrapper.value;
      //在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。
      //所以此处的读取操作确保读value之前，会读取wrapper这个引用变量指向的对象，
      //而写操作又可以确保在对象可见之前，final域已经正确初始化了。所以此处肯定会读取到正确的value。
      //如果读final域不做这个保证，那么对value的读取操作有可能会被重排到对wrapper赋值之前，有可能读取到不正确的value值。
   }
}
```

[1]: https://blog.csdn.net/java_4_ever/article/details/49633261	"通过 final 关键字来实现 双重检查(DCL) 时，为什么 局部变量 是必须的？"

