---
title: 单例模式
date: 2020-05-16 21:57:33
categories:
- 设计模式
tags:
- java
- 创建型
---

#  单例模式

单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。

<!-- more -->

## 一、应用场景

### 1、处理资源访问冲突

比如，一个往文件中打印日志的 Logger 类，我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。

单例模式相对于类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。

### 2、表示全局唯一类

从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如，配置信息类。

## 二、单例模式的实现

- 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；
- 考虑对象创建时的线程安全问题；
- 考虑是否支持延迟加载；
- 考虑 getInstance() 性能是否高（是否加锁）。

### 1、饿汉模式

饿汉式在类加载的时候，对instance 静态实例进行创建，instance 实例的创建过程是线程安全的，不支持延迟加载。

```java
public class Logger {
    private static final Logger instance = new Logger();
    private FileWriter writer;
    private Logger() { }

    public static Logger getInstance() {
        return instance;
    }
    public void log(String message) {
        writer.write(message);
    }
}
```

### 2、懒汉模式

懒汉式支持延迟加载

```java
public class Logger {
    private static Logger instance;
	private FileWriter writer;
    private Logger() {}

    public static synchronized Logger getInstance() {
        if (instance == null) {
            instance = new Logger();
        }
        return instance;
    }
    public void log(String message) {
        writer.write(message);
    }
}
```

getInstance() 这个方法加了一把锁（synchronzed），导致这个函数的并发度很低。

### 3、双重检查

既支持延迟加载、又支持高并发的单例实现方式

```java
public class Logger {
    private volatile static Logger instance;
    private FileWriter writer;
    private Logger() { }
    public static Logger getInstance() {
        if (instance == null) {
            synchronized (Logger.class) { // 此处为类级别的锁
                if (instance == null) {
                    instance = new Logger();
                }
            }
        }
        return instance;
    }
    public void log(String message) {
        writer.write(message);
    }
}
```

因为在一些编译器上存在指令排序，所以instance变量需声明为volatile类型的，避免在多线程环境下是发生问题。

### 4、静态内部类

这种实现方法既保证了线程安全，又能做到延迟加载。

```java
public class Logger {
    private FileWriter writer;
    private Logger() {}

    private static class SingletonHolder {
        private static final Logger instance = new Logger();
    }

    public static Logger getInstance() {
        return SingletonHolder.instance;
    }
    public void log(String message) {
        writer.write(message);
    }
}
```

SingletonHolder 是一个静态内部类，当外部类加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。

### 5、枚举

这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。

```java
public enum Logger {
    INSTANCE;
    private FileWriter writer;

    IdGenerator() { }

    public void log(String message) {
        writer.write(message);
    }
}
```



